# 1 "battle.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "battle.c"
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 1 3
# 10 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 11 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 1 3
# 10 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/newlib.h" 1 3
# 14 "/opt/devkitpro/devkitARM/arm-none-eabi/include/newlib.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_newlib_version.h" 1 3
# 15 "/opt/devkitpro/devkitARM/arm-none-eabi/include/newlib.h" 2 3
# 11 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/config.h" 1 3



# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 5 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/config.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/features.h" 1 3
# 6 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/config.h" 2 3
# 12 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 2 3
# 12 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3




# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 209 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4

# 209 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 321 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 17 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3

# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 1 3
# 13 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 1 3
# 14 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 143 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 15 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 1 3
# 24 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_types.h" 1 3



# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 1 3
# 41 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 55 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 77 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;
# 103 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
# 134 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 160 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 182 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;
# 200 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
# 214 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 5 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_types.h" 2 3


typedef __int64_t _off_t;


typedef __int64_t _fpos_t;


typedef __uint32_t __ino_t;


typedef __uint32_t __dev_t;
# 25 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/lock.h" 1 3




# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdint.h" 1 3 4
# 9 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdint.h" 3 4
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 1 3 4
# 13 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_intsup.h" 1 3 4
# 35 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_intsup.h" 3 4
       
       
       
       
       
       
       
# 187 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_intsup.h" 3 4
       
       
       
       
       
       
       
# 14 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 2 3 4
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_stdint.h" 1 3 4
# 20 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_stdint.h" 3 4
typedef __int8_t int8_t ;



typedef __uint8_t uint8_t ;







typedef __int16_t int16_t ;



typedef __uint16_t uint16_t ;







typedef __int32_t int32_t ;



typedef __uint32_t uint32_t ;







typedef __int64_t int64_t ;



typedef __uint64_t uint64_t ;






typedef __intmax_t intmax_t;




typedef __uintmax_t uintmax_t;




typedef __intptr_t intptr_t;




typedef __uintptr_t uintptr_t;
# 15 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 2 3 4






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;




typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;




typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;




typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
# 51 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
# 61 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
# 71 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 81 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
# 10 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdint.h" 2 3 4
# 6 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/lock.h" 2 3

typedef int32_t _LOCK_T;

struct __lock_t {
 _LOCK_T lock;
 uint32_t thread_tag;
 uint32_t counter;
};

typedef struct __lock_t _LOCK_RECURSIVE_T;

extern void __libc_lock_init(_LOCK_T *lock);
extern void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_close(_LOCK_T *lock);
extern void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_acquire(_LOCK_T *lock);
extern void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_release(_LOCK_T *lock);
extern void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock);


extern int __libc_lock_try_acquire(_LOCK_T *lock);
extern int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock);
# 26 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;
# 50 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef int __pid_t;







typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;
# 88 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;
# 129 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef unsigned int __size_t;
# 145 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef signed int _ssize_t;
# 156 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;


# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 350 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 160 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;






typedef unsigned long __clock_t;






typedef __int_least64_t __time_t;





typedef unsigned long __clockid_t;


typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;




typedef char * __va_list;
# 16 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 38 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _reent;

struct __locale_t;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 93 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 117 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 181 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (*_read) (struct _reent *, void *,
        char *, int);
  int (*_write) (struct _reent *, void *,
         const char *,
         int);
  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  int (*_close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 287 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 319 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 610 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];


  int _unspecified_locale_info;
  struct __locale_t *_locale;

  int __sdidinit;

  void (*__cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**(_sig_func))(int);




  struct _glue __sglue;

  __FILE __sf[3];

  void *deviceData;
};
# 817 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);





  struct _reent * __getreent (void);
# 19 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/cdefs.h" 1 3
# 47 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/cdefs.h" 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 48 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/cdefs.h" 2 3
# 20 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/stdlib.h" 1 3
# 21 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 33 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;




typedef int (*__compar_fn_t) (const void *, const void *);







int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((__noreturn__));
int abs (int);





int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void *__key,
         const void *__base,
         size_t __nmemb,
         size_t __size,
         __compar_fn_t _compar);
void *calloc(size_t, size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__))
      __attribute__((__alloc_size__(1, 2))) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((__noreturn__));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);




long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void *malloc(size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(1))) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int _mbtowc_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);
size_t _wcstombs_r (struct _reent *, char *restrict, const wchar_t *restrict, size_t, _mbstate_t *);
# 134 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__deprecated__("the use of `mktemp' is dangerous; use `mkstemp' instead")));
void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand (void);
void *realloc(void *, size_t) __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(2))) ;
# 156 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
void srand (unsigned __seed);
double strtod (const char *restrict __n, char **restrict __end_PTR);
double _strtod_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR);

float strtof (const char *restrict __n, char **restrict __end_PTR);







long strtol (const char *restrict __n, char **restrict __end_PTR, int __base);
long _strtol_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long strtoul (const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);
# 188 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
int system (const char *__string);
# 199 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
void _Exit (int __status) __attribute__ ((__noreturn__));




int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);



int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);
# 221 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
char * __itoa (int, char *, int);
char * __utoa (unsigned, char *, int);
# 260 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
long long atoll (const char *__nptr);

long long _atoll_r (struct _reent *, const char *__nptr);

long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *restrict __n, char **restrict __end_PTR, int __base);

long long _strtoll_r (struct _reent *, const char *restrict __n, char **restrict __end_PTR, int __base);

unsigned long long strtoull (const char *restrict __n, char **restrict __end_PTR, int __base);

unsigned long long _strtoull_r (struct _reent *, const char *restrict __n, char **restrict __end_PTR, int __base);
# 281 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
int _unsetenv_r (struct _reent *, const char *__string);







char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);
# 319 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
extern long double _strtold_r (struct _reent *, const char *restrict, char **restrict);

extern long double strtold (const char *restrict, char **restrict);
# 336 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3

# 2 "battle.c" 2
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 1 3
# 36 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 37 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 2 3



# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdarg.h" 1 3 4
# 40 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 2 3
# 61 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 1 3
# 28 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 3
typedef __uint8_t u_int8_t;


typedef __uint16_t u_int16_t;


typedef __uint32_t u_int32_t;


typedef __uint64_t u_int64_t;

typedef int register_t;
# 62 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 63 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 2 3
# 113 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 3
typedef __blkcnt_t blkcnt_t;




typedef __blksize_t blksize_t;




typedef unsigned long clock_t;





typedef __int_least64_t time_t;





typedef long daddr_t;



typedef char * caddr_t;




typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;




typedef __id_t id_t;




typedef __ino_t ino_t;
# 173 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 3
typedef __off_t off_t;



typedef __dev_t dev_t;



typedef __uid_t uid_t;



typedef __gid_t gid_t;




typedef __pid_t pid_t;




typedef __key_t key_t;




typedef _ssize_t ssize_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __clockid_t clockid_t;





typedef __timer_t timer_t;





typedef __useconds_t useconds_t;




typedef __suseconds_t suseconds_t;



typedef __int64_t sbintime_t;


# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_pthreadtypes.h" 1 3
# 240 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/types.h" 1 3
# 241 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/types.h" 2 3
# 62 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 2 3




typedef __FILE FILE;






typedef _fpos_t fpos_t;





# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/stdio.h" 1 3
# 80 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 2 3
# 186 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);



int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *restrict, const char *restrict, FILE *restrict);
void setbuf (FILE *restrict, char *restrict);
int setvbuf (FILE *restrict, char *restrict, int, size_t);
int fprintf (FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int fscanf (FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int printf (const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 1, 2)));
int scanf (const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 1, 2)));
int sscanf (const char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int vfprintf (FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int vprintf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 1, 0)));
int vsprintf (char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int fgetc (FILE *);
char * fgets (char *restrict, int, FILE *restrict);
int fputc (int, FILE *);
int fputs (const char *restrict, FILE *restrict);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t fwrite (const void *restrict , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *restrict, fpos_t *restrict);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *restrict _name, const char *restrict _type);
int sprintf (char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int remove (const char *);
int rename (const char *, const char *);
# 266 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
int snprintf (char *restrict, size_t, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int vsnprintf (char *restrict, size_t, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int vfscanf (FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int vscanf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 1, 0)));
int vsscanf (const char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
# 396 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
int _asiprintf_r (struct _reent *, char **, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
char * _asnprintf_r (struct _reent *, char *restrict, size_t *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _asprintf_r (struct _reent *, char **restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _diprintf_r (struct _reent *, int, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _dprintf_r (struct _reent *, int, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
int _fgetc_unlocked_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *restrict, int, FILE *restrict);
char * _fgets_unlocked_r (struct _reent *, char *restrict, int, FILE *restrict);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fiscanf_r (struct _reent *, FILE *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
FILE * _fmemopen_r (struct _reent *, void *restrict, size_t, const char *restrict);
FILE * _fopen_r (struct _reent *, const char *restrict, const char *restrict);
FILE * _freopen_r (struct _reent *, const char *restrict, const char *restrict, FILE *restrict);
int _fprintf_r (struct _reent *, FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputc_unlocked_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *restrict, FILE *restrict);
int _fputs_unlocked_r (struct _reent *, const char *restrict, FILE *restrict);
size_t _fread_r (struct _reent *, void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t _fread_unlocked_r (struct _reent *, void *restrict, size_t _size, size_t _n, FILE *restrict);
int _fscanf_r (struct _reent *, FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t _fwrite_unlocked_r (struct _reent *, const void *restrict, size_t _size, size_t _n, FILE *restrict);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int _iscanf_r (struct _reent *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *,
      const char *_old, const char *_new);
int _scanf_r (struct _reent *, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int _siprintf_r (struct _reent *, char *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _siscanf_r (struct _reent *, const char *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _snprintf_r (struct _reent *, char *restrict, size_t, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _sprintf_r (struct _reent *, char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _sscanf_r (struct _reent *, const char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vdprintf_r (struct _reent *, int, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _vfprintf_r (struct _reent *, FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfscanf_r (struct _reent *, FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int _vprintf_r (struct _reent *, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int _vscanf_r (struct _reent *, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vsnprintf_r (struct _reent *, char *restrict, size_t, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vsprintf_r (struct _reent *, char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vsscanf_r (struct _reent *, const char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 577 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 687 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
static __inline__ int __sputc_r(struct _reent *_ptr, int _c, FILE *_p) {




 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf_r(_ptr, _c, _p));
}
# 741 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3
static __inline int
_getchar_unlocked(void)
{
 struct _reent *_ptr;

 _ptr = (__getreent());
 return ((--(((_ptr)->_stdin))->_r < 0 ? __srget_r(_ptr, ((_ptr)->_stdin)) : (int)(*(((_ptr)->_stdin))->_p++)));
}

static __inline int
_putchar_unlocked(int _c)
{
 struct _reent *_ptr;

 _ptr = (__getreent());
 return (__sputc_r(_ptr, _c, ((_ptr)->_stdout)));
}
# 797 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdio.h" 3

# 3 "battle.c" 2
# 1 "print.h" 1
# 36 "print.h"

# 36 "print.h"
void mgba_printf_level(int level, const char* ptr, ...);
void mgba_printf(const char* string, ...);
void mgba_break(void);
uint8_t mgba_open(void);
void mgba_close(void);
# 4 "battle.c" 2
# 1 "battle.h" 1




# 1 "mode0.h" 1




typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
# 60 "mode0.h"
typedef int fp256;

extern fp256 bg2xOff, bg2yOff;


typedef struct {
    short pa, pb;
    short pc, pd;
    int dx, dy;
} BG_AFFINE;




extern const BG_AFFINE bg_aff_default;
# 84 "mode0.h"
extern volatile unsigned short *videoBuffer;
# 105 "mode0.h"
typedef struct {
    u16 tileimg[8192];
} charblock;


typedef struct {
    u16 tilemap[1024];
} screenblock;



void setPixel3(int col, int row, unsigned short color);
void drawRect3(int col, int row, int width, int height, volatile unsigned short color);
void fillScreen3(volatile unsigned short color);
void drawImage3(int col, int row, int width, int height, const unsigned short *image);
void drawFullscreenImage3(const unsigned short *image);


void setPixel4(int col, int row, unsigned char colorIndex);
void drawRect4(int col, int row, int width, int height, volatile unsigned char colorIndex);
void fillScreen4(volatile unsigned char colorIndex);
void drawImage4(int col, int row, int width, int height, const unsigned short *image);
void drawFullscreenImage4(const unsigned short *image);


void waitForVBlank();
void flipPage();




typedef struct {
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
} OBJ_ATTR;



extern OBJ_ATTR shadowOAM[];
# 177 "mode0.h"
void hideSprites();






typedef struct {
    int worldRow;
    int worldCol;
    int rdel;
    int cdel;
    int width;
    int height;
    int aniCounter;
    int aniState;
    int prevAniState;
    int curFrame;
    int numFrames;
    int hide;
} SPRITE;
# 217 "mode0.h"
extern unsigned short oldButtons;
extern unsigned short buttons;
# 227 "mode0.h"
typedef volatile struct {
    volatile const void *src;
    volatile void *dst;
    volatile unsigned int cnt;
} DMA;


extern DMA *dma;
# 267 "mode0.h"
void DMANow(int channel, volatile const void *src, volatile void *dst, unsigned int cnt);
# 303 "mode0.h"
typedef void (*ihp)(void);
# 322 "mode0.h"
int collision(int colA, int rowA, int widthA, int heightA, int colB, int rowB, int widthB, int heightB);
int collisionCheck(unsigned char *collisionMap, int mapWidth, int x, int y, int width, int height);
# 6 "battle.h" 2
# 1 "game.h" 1




# 1 "moves.h" 1





enum { OPPONENT, ALLY };

typedef struct tag_move {
    char text[10];
    char flavorText[61];
    int damage;
    int hitAll;
    int targeting;
    int healing;
} MOVE;

extern MOVE MOVE_SLASH;
extern MOVE MOVE_BLAST;
extern MOVE MOVE_HEAL;
# 33 "moves.h"
extern MOVE MOVE_NIBBLE;
extern MOVE MOVE_BITE;
extern MOVE MOVE_STRIKE;
extern MOVE MOVE_SLASH;

extern MOVE MOVE_FLAIL;
extern MOVE MOVE_PUFFUP;
extern MOVE MOVE_WAVE;

extern MOVE MOVE_REGEN;
extern MOVE MOVE_RESOLVE;
extern MOVE MOVE_SHEAL;
extern MOVE MOVE_LHEAL;
extern MOVE MOVE_SHEALBURST;
extern MOVE MOVE_LHEALBURST;

extern MOVE MOVE_DASH;
extern MOVE MOVE_TRANSCEND;

extern MOVE MOVE_TORPEDO1;
extern MOVE MOVE_TORPEDO2;
extern MOVE MOVE_SHIELD1;
extern MOVE MOVE_SHIELD2;
extern MOVE MOVE_BLAST1;
extern MOVE MOVE_BLAST2;
extern MOVE MOVE_DEATHRAY;
extern MOVE MOVE_BRUH;

extern MOVE MOVE_NONE;
# 6 "game.h" 2

extern int submarineMaxHp;
extern int submarineHp;

extern int gameVictory;


enum { FISH, SHARK, ANGLER, PUFFER, BARRACUDA, BOSS };




typedef struct tag_combatant {
    char name[10];
    int exists;
    int maxHp;
    int hp;
    int numMoves;
    MOVE* moves[6];
    int tileid;
} COMBATANT;


extern COMBATANT CBT_FISH;
extern COMBATANT CBT_SHARK;
extern COMBATANT CBT_ANGLER;
extern COMBATANT CBT_PUFFER;
extern COMBATANT CBT_BARRACUDA;
extern COMBATANT CBT_GOD;
extern COMBATANT CBT_SUBMARINE;
extern COMBATANT CBT_NONE;
# 47 "game.h"
extern COMBATANT battleAllies[4];
extern COMBATANT battleOpponents[4];


extern int cheater;


void initGame();
void initParty();


int tilesRed(int tile1, int hp, int maxHp, int segments);
# 7 "battle.h" 2
# 84 "battle.h"
extern const int text_tile_lkup[];


enum { TURNINDICATOR = 0, ALLY1_B, ALLY2_B, ALLY3_B, ALLY4_B, ENEMY1_B, ENEMY2_B, ENEMY3_B, ENEMY4_B, HB1, HB2, HB3,
 HB4, HB5, HB6, HB7, HB8, TARGETING_ARROW, TARGETING_ARROW2, TARGETING_ARROW3, TARGETING_ARROW4,
 TURNICON1, TURNICON2, TURNICON3, TURNICON4, TURNICON5, TURNICON6, TURNICON7, TURNICON8,
 TEXT_IDX };
# 106 "battle.h"
extern int lettersActive;
void eraseAllText();
void drawText(char* str, int textboxX, int textboxY, int textboxWidth, int textboxHeight);
void setTopText(char* str);
void setBottomText(char* str);
char tsel(int cond);


enum { LOST = -1, ONGOING = 0, WON = 1 };
extern int battleStatus;
extern int bossBattle;
extern int waiting;
extern int turnPoints;
extern int nextTurnPoints;
extern int fighterIdx;
extern int nextFighterIdx;


enum { PLAYERTURN, ENEMYTURN };
extern int turn;
extern int nextTurn;


enum { FRONTMENU, ATTACKMENU, TARGETMENU, INSPECTMENU, CAPTUREMENU, REPLACEMENU };


enum { PLAYERTEAM, ENEMYTEAM };


void initBattle(int opponentType);
void resetOpponents();


void updateBattle();
void drawCombatants();
void checkBattleStatus();


void goToFrontMenu();
void goToAttackMenu();
void goToTargetMenu();
void goToInspectMenu();
void goToCaptureMenu();
void goToReplaceMenu();
void frontMenu();
void attackMenu();
void targetMenu();
void inspectMenu();
void captureMenu();
void replaceMenu();
void executeMove(MOVE* m, COMBATANT* t);
void finishTurn();
# 5 "battle.c" 2
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 1 3
# 17 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 18 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 2 3
# 27 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3



# 29 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3
void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *restrict, const void *restrict, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *restrict, const char *restrict);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *restrict, const char *restrict);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *restrict, const char *restrict, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *restrict, const char *restrict, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);

char *strtok (char *restrict, const char *restrict);

size_t strxfrm (char *restrict, const char *restrict, size_t);
# 86 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3
char *_strdup_r (struct _reent *, const char *);



char *_strndup_r (struct _reent *, const char *, size_t);
# 112 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3
char * _strerror_r (struct _reent *, int, int, int *);
# 134 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3
char *strsignal (int __signo);
# 175 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/string.h" 1 3
# 176 "/opt/devkitpro/devkitARM/arm-none-eabi/include/string.h" 2 3


# 6 "battle.c" 2
# 1 "sound.h" 1

# 1 "sound.h"
void setupSounds();
void playSoundA(const signed char* sound, int length, int loops, int offset);
void playSoundB(const signed char* sound, int length, int loops);

void setupSoundInterrupts();
void soundInterruptHandler();

void pauseSound();
void unpauseSound();
void stopSound();
# 49 "sound.h"
typedef struct{
    const signed char* data;
    int length;
    int frequency;
    int isPlaying;
    int loops;
    int duration;
    int priority;
    int vBlankCount;
} SOUND;

SOUND soundA;
SOUND soundB;
# 7 "battle.c" 2
# 1 "damagesfx.h" 1


extern const unsigned int damagesfx_sampleRate;
extern const unsigned int damagesfx_length;
extern const signed char damagesfx_data[];
# 8 "battle.c" 2
# 1 "fanfaresfx.h" 1


extern const unsigned int fanfaresfx_sampleRate;
extern const unsigned int fanfaresfx_length;
extern const signed char fanfaresfx_data[];
# 9 "battle.c" 2
# 1 "menuhighsfx.h" 1


extern const unsigned int menuhighsfx_sampleRate;
extern const unsigned int menuhighsfx_length;
extern const signed char menuhighsfx_data[];
# 10 "battle.c" 2
# 1 "menulowsfx.h" 1


extern const unsigned int menulowsfx_sampleRate;
extern const unsigned int menulowsfx_length;
extern const signed char menulowsfx_data[];
# 11 "battle.c" 2


const int text_tile_lkup[] = {((0)*32 + ((0)*2)),((0)*32 + ((1)*2)),((0)*32 + ((2)*2)),((0)*32 + ((3)*2)),
((0)*32 + ((4)*2)),((0)*32 + ((5)*2)),((0)*32 + ((6)*2)),((0)*32 + ((7)*2)),((1)*32 + ((0)*2)),
((1)*32 + ((1)*2)),((1)*32 + ((2)*2)),((1)*32 + ((3)*2)),((1)*32 + ((4)*2)),((1)*32 + ((5)*2)),((1)*32 + ((6)*2)),((1)*32 + ((7)*2)),((2)*32 + ((0)*2)),
((2)*32 + ((1)*2)),((2)*32 + ((2)*2)),((2)*32 + ((3)*2)),((2)*32 + ((4)*2)),((2)*32 + ((5)*2)),((2)*32 + ((6)*2)),((2)*32 + ((7)*2)),((3)*32 + ((0)*2)),((3)*32 + ((1)*2)),((3)*32 + ((2)*2)),
((3)*32 + ((3)*2)),((3)*32 + ((4)*2)),((3)*32 + ((5)*2)),((3)*32 + ((6)*2)),((3)*32 + ((7)*2)),((4)*32 + ((0)*2)),((4)*32 + ((1)*2)),((4)*32 + ((2)*2)),((4)*32 + ((3)*2)),
((4)*32 + ((4)*2)),((4)*32 + ((5)*2)),((4)*32 + ((6)*2)),((4)*32 + ((7)*2)),((5)*32 + ((0)*2)),((5)*32 + ((1)*2)),((5)*32 + ((2)*2)),((5)*32 + ((3)*2)),((5)*32 + ((4)*2)),((5)*32 + ((5)*2)),((5)*32 + ((6)*2)),((5)*32 + ((7)*2)),
((6)*32 + ((0)*2)),((6)*32 + ((1)*2)),((6)*32 + ((2)*2)),((6)*32 + ((3)*2)),((6)*32 + ((4)*2)),((6)*32 + ((5)*2)),((6)*32 + ((6)*2)),((6)*32 + ((7)*2)),((7)*32 + ((0)*2)),((7)*32 + ((1)*2)),((7)*32 + ((2)*2)),
((7)*32 + ((3)*2)),((7)*32 + ((4)*2)),((7)*32 + ((5)*2)),((7)*32 + ((6)*2)),((7)*32 + ((7)*2))};

int lettersActive;

int battleStatus;
int turn;
int targetTeam;
COMBATANT* fighter;
int fighterIdx;
MOVE* move;
int turnPoints;
int nextTurnPoints;
int nextFighterIdx;
int nextTurn;
COMBATANT* captured;

int menu;
int selOpt;
int numOpt;
int waiting;

int enter;
int leave;

char topBuf[63];
char botBuf[63];

int bossBattle;


void initBattle(int opponentType) {
    battleStatus = ONGOING;
    lettersActive = 0;
    goToFrontMenu();
    waiting = 0;
    enter = 0;
    leave = 0;
    topBuf[0] = '\0';
    botBuf[0] = '\0';

    turn = PLAYERTURN;
    fighter = &battleAllies[0];
    fighterIdx = 0;
    captured = 
# 63 "battle.c" 3 4
              ((void *)0)
# 63 "battle.c"
                  ;
    move = 
# 64 "battle.c" 3 4
          ((void *)0)
# 64 "battle.c"
              ;
    turnPoints = 0;
    for (int i = 0; i < 4; i++) {
        if (battleAllies[i].exists && battleAllies[i].hp > 0) {
            turnPoints++;
        }
    }

    nextTurnPoints = turnPoints;
    nextFighterIdx = fighterIdx;
    nextTurn = turn;
    *(volatile unsigned short*)0x400010A = (0<<7);

    bossBattle = 0;

    resetOpponents();

    switch (opponentType)
    {
    case FISH:
        battleOpponents[0] = CBT_FISH;
        battleOpponents[1] = CBT_FISH;
        battleOpponents[2] = CBT_NONE;
        battleOpponents[3] = CBT_NONE;
        break;
    case SHARK:
        battleOpponents[0] = CBT_SHARK;
        battleOpponents[1] = CBT_SHARK;
        battleOpponents[2] = CBT_FISH;
        battleOpponents[3] = CBT_NONE;
        break;
    case ANGLER:
        battleOpponents[0] = CBT_ANGLER;
        battleOpponents[1] = CBT_SHARK;
        battleOpponents[2] = CBT_SHARK;
        battleOpponents[3] = CBT_FISH;
        break;
    case PUFFER:
        battleOpponents[0] = CBT_PUFFER;
        battleOpponents[1] = CBT_SHARK;
        battleOpponents[2] = CBT_FISH;
        battleOpponents[3] = CBT_FISH;
        break;
    case BARRACUDA:
        battleOpponents[0] = CBT_BARRACUDA;
        battleOpponents[1] = CBT_BARRACUDA;
        battleOpponents[2] = CBT_SHARK;
        battleOpponents[3] = CBT_FISH;
        break;
    case BOSS:
        bossBattle = 1;
        battleOpponents[0] = CBT_GOD;
        battleOpponents[1] = CBT_BARRACUDA;
        battleOpponents[2] = CBT_PUFFER;
        battleOpponents[3] = CBT_SHARK;
        break;
    default:
        battleOpponents[0] = CBT_FISH;
        battleOpponents[1] = CBT_NONE;
        battleOpponents[2] = CBT_NONE;
        battleOpponents[3] = CBT_NONE;
        break;
    }

    drawCombatants();
}

void goToFrontMenu() {
    menu = FRONTMENU;
    numOpt = 4;
    selOpt = 0;
}

void goToAttackMenu() {
    menu = ATTACKMENU;
    numOpt = fighter->numMoves;
    selOpt = 0;
}

void goToTargetMenu() {
    menu = TARGETMENU;
    numOpt = 4;
    if (targetTeam == ENEMYTEAM) {
        for (int i = 0; i < 4; i++) {
            if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                selOpt = i;
                break;
            }
        }
    } else {
        for (int i = 0; i < 4; i++) {
            if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                selOpt = i;
                break;
            }
        }
    }

}

void goToInspectMenu() {
    menu = INSPECTMENU;
    numOpt = 4;
    for (int i = 0; i < 4; i++) {
        if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
            selOpt = i;
            break;
        }
    }
    targetTeam = ENEMYTEAM;
}

void goToCaptureMenu() {
    menu = CAPTUREMENU;
    numOpt = 4;
    for (int i = 0; i < 4; i++) {
        if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
            selOpt = i;
            break;
        }
    }
    targetTeam = ENEMYTEAM;
}

void goToReplaceMenu() {
    menu = REPLACEMENU;
    numOpt = 3;
    selOpt = 0;
    targetTeam = PLAYERTEAM;
}

void replaceMenu() {
    int realOpt = selOpt + 1;
    sprintf(topBuf, "YOU CAPTURED A\n%s! SELECT\nAN ALLY TO REPLACE.", captured->name);
    shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * realOpt) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
    shadowOAM[TARGETING_ARROW].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
    shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
    sprintf(botBuf, "%s:%d/%d", battleAllies[realOpt].name, battleAllies[realOpt].hp, battleAllies[realOpt].maxHp);
    if (leave) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        sprintf(topBuf, "YOU RELEASED\n%s.", captured->name);
        captured->exists = 0;
        finishTurn();
    } else if (enter) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        botBuf[0] = '\0';
        sprintf(topBuf, "%s REPLACED\n%s.", captured->name, battleAllies[realOpt].name);
        battleAllies[realOpt] = *captured;
        captured->exists = 0;

        if (battleAllies[realOpt].hp < battleAllies[realOpt].maxHp / 2) battleAllies[realOpt].hp = battleAllies[realOpt].maxHp / 2;
        finishTurn();
    }
}

void captureMenu() {
    strncpy(topBuf, "CHOOSE AN OPPONENT\nTO CAPTURE.", 61);
    shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * selOpt) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
    shadowOAM[TARGETING_ARROW].attr1 = (192 & 0x1FF) | (0 << 14);
    shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
    sprintf(botBuf, "%s:%d/%d", battleOpponents[selOpt].name, battleOpponents[selOpt].hp, battleOpponents[selOpt].maxHp);

    if (leave) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        goToFrontMenu();
    } else if (enter) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        botBuf[0] = '\0';
        if (bossBattle) {
            sprintf(topBuf, "YOU CANNOT\nCAPTURE SUCH A\nFIERCE OPPONENT!");
            finishTurn();
        } else {

            int r = rand() % (battleOpponents[selOpt].maxHp);
            if (battleOpponents[selOpt].hp < r) {
                captured = &battleOpponents[selOpt];
                goToReplaceMenu();
            } else {
                sprintf(topBuf, "YOU FAILED TO\nCAPTURE %s.", battleOpponents[selOpt].name);
                finishTurn();
            }
        }
    }
}

void inspectMenu() {
    strncpy(topBuf, "CHOOSE A COMBATANT\nTO INSPECT.", 61);
    if (targetTeam == ENEMYTEAM) {
        shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * selOpt) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
        shadowOAM[TARGETING_ARROW].attr1 = (192 & 0x1FF) | (0 << 14);
        shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
        sprintf(botBuf, "%s:%d/%d", battleOpponents[selOpt].name, battleOpponents[selOpt].hp, battleOpponents[selOpt].maxHp);
    } else {
        shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * selOpt) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
        shadowOAM[TARGETING_ARROW].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
        shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
        sprintf(botBuf, "%s:%d/%d", battleAllies[selOpt].name, battleAllies[selOpt].hp, battleAllies[selOpt].maxHp);
    }

    if (leave) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        goToFrontMenu();
    }
}

void frontMenu() {
    strncpy(topBuf, "WHAT WILL YOU DO?", 61);
    sprintf(botBuf, "%cATTACK   %cCAPTURE\n%cPASS\n%cINSPECT", tsel(selOpt == 0), tsel(selOpt == 3), tsel(selOpt == 1), tsel(selOpt == 2));
    if (enter) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        switch (selOpt)
        {
        case 0:
            goToAttackMenu();
            break;
        case 1:
            sprintf(topBuf, "%s PASSED.", fighter->name);
            botBuf[0] = '\0';
            finishTurn();
            break;
        case 2:
            goToInspectMenu();
            break;
        case 3:
            goToCaptureMenu();
            break;
        }
    }
}

void attackMenu() {
    strncpy(topBuf, "CHOOSE AN ATTACK.", 61);
    sprintf(botBuf, "%c%-9s%c%-9s%c%-9s%c%-9s%c%-9s%c%-9s",
            tsel(selOpt == 0), fighter->moves[0]->text, tsel(selOpt == 3), fighter->moves[3]->text,
            tsel(selOpt == 1), fighter->moves[1]->text, tsel(selOpt == 4), fighter->moves[4]->text,
            tsel(selOpt == 2), fighter->moves[2]->text, tsel(selOpt == 5), fighter->moves[5]->text);
    if (leave) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        goToFrontMenu();
    } else if (enter) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        move = fighter->moves[selOpt];
        targetTeam = move->targeting == OPPONENT ? ENEMYTEAM : PLAYERTEAM;
        goToTargetMenu();
    }
}

void targetMenu() {
    strncpy(topBuf, "CHOOSE A TARGET.", 61);

    if (move == &MOVE_REGEN || move == &MOVE_RESOLVE || move == &MOVE_DASH || move == &MOVE_TRANSCEND) {
        selOpt = fighterIdx;
    }
    if (targetTeam == ENEMYTEAM) {
        if (move->hitAll) {
            if (battleOpponents[0].exists && battleOpponents[0].hp > 0) {
                shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * 0) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW].attr1 = (192 & 0x1FF) | (0 << 14);
                shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
            }
            if (battleOpponents[1].exists && battleOpponents[1].hp > 0) {
                shadowOAM[TARGETING_ARROW + 1].attr0 = ((15 + 40 * 1) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW + 1].attr1 = (192 & 0x1FF) | (0 << 14);
                shadowOAM[TARGETING_ARROW + 1].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW + 1].attr0 = (2 << 8);
            }
            if (battleOpponents[2].exists && battleOpponents[2].hp > 0) {
                shadowOAM[TARGETING_ARROW + 2].attr0 = ((15 + 40 * 2) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW + 2].attr1 = (192 & 0x1FF) | (0 << 14);
                shadowOAM[TARGETING_ARROW + 2].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW + 2].attr0 = (2 << 8);
            }
            if (battleOpponents[3].exists && battleOpponents[3].hp > 0) {
                shadowOAM[TARGETING_ARROW + 3].attr0 = ((15 + 40 * 3) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW + 3].attr1 = (192 & 0x1FF) | (0 << 14);
                shadowOAM[TARGETING_ARROW + 3].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW + 3].attr0 = (2 << 8);
            }
            sprintf(botBuf, "%s WILL AFFECT\nALL ENEMIES", move->text);
        } else {
            shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * selOpt) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
            shadowOAM[TARGETING_ARROW].attr1 = (192 & 0x1FF) | (0 << 14);
            shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
            sprintf(botBuf, "%s:%d/%d", battleOpponents[selOpt].name, battleOpponents[selOpt].hp, battleOpponents[selOpt].maxHp);
        }
    } else {
        if (move->hitAll) {
            if (battleAllies[0].exists && battleAllies[0].hp > 0) {
                shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * 0) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
                shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
            }
            if (battleAllies[1].exists && battleAllies[1].hp > 0) {
                shadowOAM[TARGETING_ARROW + 1].attr0 = ((15 + 40 * 1) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW + 1].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
                shadowOAM[TARGETING_ARROW + 1].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW + 1].attr0 = (2 << 8);
            }
            if (battleAllies[2].exists && battleAllies[2].hp > 0) {
                shadowOAM[TARGETING_ARROW + 2].attr0 = ((15 + 40 * 2) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW + 2].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
                shadowOAM[TARGETING_ARROW + 2].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW + 2].attr0 = (2 << 8);
            }
            if (battleAllies[3].exists && battleAllies[3].hp > 0) {
                shadowOAM[TARGETING_ARROW + 3].attr0 = ((15 + 40 * 3) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
                shadowOAM[TARGETING_ARROW + 3].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
                shadowOAM[TARGETING_ARROW + 3].attr2 = ((26)*32 + ((0)*2));
            } else {
                shadowOAM[TARGETING_ARROW + 3].attr0 = (2 << 8);
            }
            sprintf(botBuf, "%s WILL\nAFFECT ALL ALLIES", move->text);
        } else {
            shadowOAM[TARGETING_ARROW].attr0 = ((15 + 40 * selOpt) & 0xFF) | (0 << 8) | (2 << 14) | (1 << 13);
            shadowOAM[TARGETING_ARROW].attr1 = (40 & 0x1FF) | (0 << 14) | (1 << 12);
            shadowOAM[TARGETING_ARROW].attr2 = ((26)*32 + ((0)*2));
            sprintf(botBuf, "%s:%d/%d", battleAllies[selOpt].name, battleAllies[selOpt].hp, battleAllies[selOpt].maxHp);
        }
    }

    if (leave) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        shadowOAM[TARGETING_ARROW + 1].attr0 = (2 << 8);
        shadowOAM[TARGETING_ARROW + 2].attr0 = (2 << 8);
        shadowOAM[TARGETING_ARROW + 3].attr0 = (2 << 8);
        goToAttackMenu();
    } else if (enter) {
        playSoundB(menuhighsfx_data, menuhighsfx_length, 0);
        shadowOAM[TARGETING_ARROW].attr0 = (2 << 8);
        shadowOAM[TARGETING_ARROW + 1].attr0 = (2 << 8);
        shadowOAM[TARGETING_ARROW + 2].attr0 = (2 << 8);
        shadowOAM[TARGETING_ARROW + 3].attr0 = (2 << 8);
        if (targetTeam == ENEMYTEAM) {
            executeMove(move, &battleOpponents[selOpt]);
        } else {
            executeMove(move, &battleAllies[selOpt]);
        }
    }
}

void executeMove(MOVE* m, COMBATANT* t) {
    mgba_printf("Executing move! Enemy turn: %d, Fighter %s, Target: %s", turn, fighter->name, t->name);
    if (m->healing) {
        playSoundB(fanfaresfx_data, fanfaresfx_length, 0);
    } else {
        playSoundB(damagesfx_data, damagesfx_length, 0);
    }
    if (m->hitAll) {
        if (targetTeam == ENEMYTEAM) {
            for (int i = 0; i < 4; i++) {

                if (battleOpponents[i].exists && (battleOpponents[i].hp > 0 || bossBattle)) {
                    battleOpponents[i].hp -= m->damage;
                    battleOpponents[i].hp += m->healing;
                    if (battleOpponents[i].hp > battleOpponents[i].maxHp) {
                        battleOpponents[i].hp = battleOpponents[i].maxHp;
                    }
                }
            }
        } else {
            for (int i = 0; i < 4; i++) {
                if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                    battleAllies[i].hp -= m->damage;
                    battleAllies[i].hp += m->healing;
                    if (battleAllies[i].hp > battleAllies[i].maxHp) {
                        battleAllies[i].hp = battleAllies[i].maxHp;
                    }
                }
            }
        }
    } else {
        t->hp -= m->damage;
        t->hp += m->healing;
        if (t->hp > t->maxHp) {
            t->hp = t->maxHp;
        }
    }
    if (m == &MOVE_DASH) {
        turnPoints += 2;
        if (turnPoints > 9) turnPoints = 9;
    }
    if (m == &MOVE_TRANSCEND) {
        fighter->hp = fighter->maxHp;
    }

    for (int i = 0; i < 4; i++) {
        if (battleOpponents[i].exists && battleOpponents[i].hp < 0) {
            battleOpponents[i].hp = 0;
        }
    }

    sprintf(topBuf, m->flavorText, fighter->name, t->name);
    botBuf[0] = '\0';


    for (int i = 1; i < 4; i++) {

        if (battleAllies[i].exists && battleAllies[i].hp <= 0) {
            battleAllies[i] = CBT_NONE;
        }
    }

    finishTurn();
}


void finishTurn() {
    goToFrontMenu();
    mgba_printf("Ending turn...");
    turnPoints--;

    nextTurnPoints = turnPoints;

    nextFighterIdx = fighterIdx;
    nextTurn = turn;

    if (turnPoints == 0) {
        if (turn == PLAYERTURN) {
            nextTurn = ENEMYTURN;
            for (int i = 0; i < 4; i++) {
                if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                    nextTurnPoints++;
                }
            }
            if (bossBattle) {
                nextTurnPoints += 1;
            }
            for (int i = 0; i < 4; i++) {
                if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                    nextFighterIdx = i;
                    fighter = &battleOpponents[i];
                    break;
                }
            }
        } else {
            nextTurn = PLAYERTURN;
            for (int i = 0; i < 4; i++) {
                if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                    nextTurnPoints++;
                }
            }
            for (int i = 0; i < 4; i++) {
                if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                    nextFighterIdx = i;
                    fighter = &battleAllies[i];
                    break;
                }
            }
        }
    } else {
        if (turn == PLAYERTURN) {
            for (int i = 1; i < 5; i++) {
                if (battleAllies[(fighterIdx + i) % 4].exists && battleAllies[(fighterIdx + i) % 4].hp > 0) {
                    nextFighterIdx = (fighterIdx + i) % 4;
                    fighter = &battleAllies[nextFighterIdx];
                    break;
                }
            }
        } else {
            for (int i = 1; i < 5; i++) {
                if (battleOpponents[(fighterIdx + i) % 4].exists && battleOpponents[(fighterIdx + i) % 4].hp > 0) {
                    nextFighterIdx = (fighterIdx + i) % 4;
                    fighter = &battleOpponents[nextFighterIdx];
                    break;
                }
            }
        }
    }

    waiting = 1;
    *(volatile unsigned short*)0x400010A = 0;
    *(volatile unsigned short*)0x4000108 = 0 - (16384 * 2);
    *(volatile unsigned short*)0x400010A = (1<<7) | 3 | (1<<6);
}


void checkBattleStatus() {
    int winTest = 1;
    for (int i = 0; i < 4; i++) {
        if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
            winTest = 0;
            break;
        }
    }
    if (winTest) {
        battleStatus = WON;
        if (bossBattle) {
            gameVictory = 1;
        }
    }
    int loseTest = 1;
    for (int i = 0; i < 4; i++) {
        if (battleAllies[i].exists && battleAllies[i].hp > 0) {
            loseTest = 0;
            break;
        }
    }
    if (loseTest) {
        battleStatus = LOST;
    }
}


void updateBattle() {
    if (waiting) {
        return;
    }
    checkBattleStatus();
    if (battleStatus != ONGOING) { return; }
    enter = 0;
    leave = 0;
    if (turn == PLAYERTURN) {

        if (menu == REPLACEMENU) {
            if ((!(~(oldButtons) & ((1 << 7))) && (~buttons & ((1 << 7))))) {
                if (selOpt < numOpt - 1) {
                    selOpt += 1;
                    playSoundB(menulowsfx_data, menulowsfx_length, 0);
                }
            } else if ((!(~(oldButtons) & ((1 << 6))) && (~buttons & ((1 << 6))))) {
                if (selOpt != 0) {
                    selOpt -= 1;
                    playSoundB(menulowsfx_data, menulowsfx_length, 0);
                }
            }
        } else if (menu == TARGETMENU || menu == INSPECTMENU || menu == CAPTUREMENU) {
            if ((!(~(oldButtons) & ((1 << 7))) && (~buttons & ((1 << 7))))) {
                if (targetTeam == ENEMYTEAM) {
                    for (int i = selOpt + 1; i < 4; i++) {
                        if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                            selOpt = i;
                            playSoundB(menulowsfx_data, menulowsfx_length, 0);
                            break;
                        }
                    }
                } else {
                    for (int i = selOpt + 1; i < 4; i++) {
                        if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                            selOpt = i;
                            playSoundB(menulowsfx_data, menulowsfx_length, 0);
                            break;
                        }
                    }
                }
            } else if ((!(~(oldButtons) & ((1 << 6))) && (~buttons & ((1 << 6))))) {
                if (targetTeam == ENEMYTEAM) {
                    for (int i = selOpt - 1; i >= 0; i--) {
                        if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                            selOpt = i;
                            playSoundB(menulowsfx_data, menulowsfx_length, 0);
                            break;
                        }
                    }
                } else {
                    for (int i = selOpt - 1; i >= 0; i--) {
                        if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                            selOpt = i;
                            playSoundB(menulowsfx_data, menulowsfx_length, 0);
                            break;
                        }
                    }
                }
            }
            if (menu == INSPECTMENU) {
                if ((!(~(oldButtons) & ((1 << 4))) && (~buttons & ((1 << 4)))) && targetTeam == PLAYERTEAM) {
                    targetTeam = ENEMYTEAM;
                    for (int i = 0; i < 4; i++) {
                        if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                            selOpt = i;
                            playSoundB(menulowsfx_data, menulowsfx_length, 0);
                            break;
                        }
                    }
                } else if ((!(~(oldButtons) & ((1 << 5))) && (~buttons & ((1 << 5)))) && targetTeam == ENEMYTEAM) {
                    targetTeam = PLAYERTEAM;
                    for (int i = 0; i < 4; i++) {
                        if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                            selOpt = i;
                            playSoundB(menulowsfx_data, menulowsfx_length, 0);
                            break;
                        }
                    }
                }
            }
        } else {
            if ((!(~(oldButtons) & ((1 << 7))) && (~buttons & ((1 << 7))))) {
                if (selOpt < numOpt - 1) {
                    if (selOpt != 2 && selOpt != 5) {
                        selOpt += 1;
                        playSoundB(menulowsfx_data, menulowsfx_length, 0);
                    }
                }
            } else if ((!(~(oldButtons) & ((1 << 6))) && (~buttons & ((1 << 6))))) {
                if (selOpt != 0 && selOpt != 3) {
                    selOpt -= 1;
                    playSoundB(menulowsfx_data, menulowsfx_length, 0);
                }
            }
            if ((!(~(oldButtons) & ((1 << 4))) && (~buttons & ((1 << 4))))) {
                if (selOpt < numOpt - 3) {
                    if (selOpt < 3) {
                        selOpt += 3;
                        playSoundB(menulowsfx_data, menulowsfx_length, 0);
                    }
                }
            } else if ((!(~(oldButtons) & ((1 << 5))) && (~buttons & ((1 << 5))))) {
                if (selOpt > 2) {
                    selOpt -= 3;
                    playSoundB(menulowsfx_data, menulowsfx_length, 0);
                }
            }
        }

        if ((!(~(oldButtons) & ((1 << 0))) && (~buttons & ((1 << 0))))) {
            enter = 1;
        }
        if ((!(~(oldButtons) & ((1 << 1))) && (~buttons & ((1 << 1))))) {
            leave = 1;
        }



        switch (menu)
        {
        case FRONTMENU:
            frontMenu();
            break;
        case ATTACKMENU:
            attackMenu();
            break;
        case TARGETMENU:
            targetMenu();
            break;
        case INSPECTMENU:
            inspectMenu();
            break;
        case CAPTUREMENU:
            captureMenu();
            break;
        case REPLACEMENU:
            replaceMenu();
            break;
        }
    } else {
        int skip = rand() % 7;
        if (skip == 6) {
            sprintf(topBuf, "%s PASSED", fighter->name);
            finishTurn();
        } else {
            int nm = fighter->numMoves;
            if (bossBattle && fighterIdx == 0) {
                nm -= 1;
            }
            int mi = rand() % nm;
            if (bossBattle && fighterIdx == 0 && fighter->hp < 10) {
                mi = 5;
            }
            if (fighter->moves[mi]->targeting == OPPONENT) {
                targetTeam = PLAYERTEAM;
                int numopps = 0;
                for (int i = 0; i < 4; i++) {
                    if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                        numopps++;
                    }
                }
                int ta = rand() % numopps;
                for (int i = 0; i < 4; i++) {
                    if (battleAllies[i].exists && battleAllies[i].hp > 0) {
                        if (ta == 0) {
                            executeMove(fighter->moves[mi], &battleAllies[i]);
                            break;
                        } else {
                            ta--;
                        }
                    }
                }
            } else {
                targetTeam = ENEMYTEAM;
                int numfriends = 0;
                for (int i = 0; i < 4; i++) {
                    if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                        numfriends++;
                    }
                }
                int ta = rand() % numfriends;
                for (int i = 0; i < 4; i++) {
                    if (battleOpponents[i].exists && battleOpponents[i].hp > 0) {
                        if (ta == 0) {
                            executeMove(fighter->moves[mi], &battleOpponents[i]);
                            break;
                        } else {
                            ta--;
                        }
                    }
                }
            }
        }
    }

    eraseAllText();
    setTopText(topBuf);
    setBottomText(botBuf);
    drawCombatants();
}


void resetOpponents() {
    for (int i = 0; i < 4; i++) {
        battleOpponents[i].exists = 0;
    }
}



char tsel(int cond) {
    return cond ? '*' : ' ';
}


void drawHealthbar(int x, int y, COMBATANT* c, int spriteIdx, int barId) {

    shadowOAM[spriteIdx].attr0 = ((y) & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[spriteIdx].attr1 = ((x) & 0x1FF) | (1 << 14);

    shadowOAM[spriteIdx].attr2 = ((14)*32 + ((0)*2)) + (barId * 8);

    int gCol = ((c->hp * 30) / (c->maxHp));


    unsigned volatile short *vb = (unsigned short *)0x06013800 + 8 + (barId * 128);

    char l = 8;
    char r = 8;

    for (int i = 0; i < 4; i++) {
        r = 1 <= gCol ? 8 : 2;
        vb[0 + (i * 4)] = 11 | (r << 8);
        l = 2 <= gCol ? 8 : 2;
        r = 3 <= gCol ? 8 : 2;
        vb[1 + (i * 4)] = l | (r << 8);
        l = 4 <= gCol ? 8 : 2;
        r = 5 <= gCol ? 8 : 2;
        vb[2 + (i * 4)] = l | (r << 8);
        l = 6 <= gCol ? 8 : 2;
        r = 7 <= gCol ? 8 : 2;
        vb[3 + (i * 4)] = l | (r << 8);
    }
    vb = (vb + 32);
    for (int i = 0; i < 4; i++) {
        l = 8 <= gCol ? 8 : 2;
        r = 9 <= gCol ? 8 : 2;
        vb[0 + (i * 4)] = l | (r << 8);
        l = 10 <= gCol ? 8 : 2;
        r = 11 <= gCol ? 8 : 2;
        vb[1 + (i * 4)] = l | (r << 8);
        l = 12 <= gCol ? 8 : 2;
        r = 13 <= gCol ? 8 : 2;
        vb[2 + (i * 4)] = l | (r << 8);
        l = 14 <= gCol ? 8 : 2;
        r = 15 <= gCol ? 8 : 2;
        vb[3 + (i * 4)] = l | (r << 8);
    }
    vb = (vb + 32);
    for (int i = 0; i < 4; i++) {
        l = 16 <= gCol ? 8 : 2;
        r = 17 <= gCol ? 8 : 2;
        vb[0 + (i * 4)] = l | (r << 8);
        l = 18 <= gCol ? 8 : 2;
        r = 19 <= gCol ? 8 : 2;
        vb[1 + (i * 4)] = l | (r << 8);
        l = 20 <= gCol ? 8 : 2;
        r = 21 <= gCol ? 8 : 2;
        vb[2 + (i * 4)] = l | (r << 8);
        l = 22 <= gCol ? 8 : 2;
        r = 23 <= gCol ? 8 : 2;
        vb[3 + (i * 4)] = l | (r << 8);
    }
    vb = (vb + 32);
    for (int i = 0; i < 4; i++) {
        l = 24 <= gCol ? 8 : 2;
        r = 25 <= gCol ? 8 : 2;
        vb[0 + (i * 4)] = l | (r << 8);
        l = 26 <= gCol ? 8 : 2;
        r = 27 <= gCol ? 8 : 2;
        vb[1 + (i * 4)] = l | (r << 8);
        l = 28 <= gCol ? 8 : 2;
        r = 29 <= gCol ? 8 : 2;
        vb[2 + (i * 4)] = l | (r << 8);
        l = 30 <= gCol ? 8 : 2;
        vb[3 + (i * 4)] = l | (11 << 8);
    }
}


void drawCombatants() {

    shadowOAM[TURNICON1].attr0 = (2 << 8);
    shadowOAM[TURNICON2].attr0 = (2 << 8);
    shadowOAM[TURNICON3].attr0 = (2 << 8);
    shadowOAM[TURNICON4].attr0 = (2 << 8);
    shadowOAM[TURNICON5].attr0 = (2 << 8);
    shadowOAM[TURNICON6].attr0 = (2 << 8);
    shadowOAM[TURNICON7].attr0 = (2 << 8);
    shadowOAM[TURNICON8].attr0 = (2 << 8);
    for (int i = turnPoints - 1; i >= 0; i--) {
        shadowOAM[TURNICON8 - i].attr0 = (41 & 0xFF) | (0 << 8) | (0 << 14) | (1 << 13);
        shadowOAM[TURNICON8 - i].attr1 = ((57 + 9 * i) & 0x1FF) | (0 << 14);
        shadowOAM[TURNICON8 - i].attr2 = ((26)*32 + ((1)*2));
    }

    shadowOAM[TURNINDICATOR].attr0 = ((15 + (40 * fighterIdx)) & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    if (turn == PLAYERTURN) {
        shadowOAM[TURNINDICATOR].attr1 = (8 & 0x1FF) | (2 << 14);
    } else {
        shadowOAM[TURNINDICATOR].attr1 = (200 & 0x1FF) | (2 << 14);
    }
    shadowOAM[TURNINDICATOR].attr2 = ((16)*32 + ((4)*2));

    if (battleAllies[0].exists && battleAllies[0].hp > 0) {
        shadowOAM[ALLY1_B].attr0 = (15 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ALLY1_B].attr1 = (8 & 0x1FF) | (2 << 14);
        shadowOAM[ALLY1_B].attr2 = battleAllies[0].tileid;
        drawHealthbar(8, 15 - 8, &battleAllies[0], HB1, 0);
    } else {
        shadowOAM[ALLY1_B].attr0 = (2 << 8);
        shadowOAM[HB1].attr0 = (2 << 8);
    }
    if (battleAllies[1].exists && battleAllies[1].hp > 0) {
        shadowOAM[ALLY2_B].attr0 = (55 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ALLY2_B].attr1 = (8 & 0x1FF) | (2 << 14);
        shadowOAM[ALLY2_B].attr2 = battleAllies[1].tileid;
        drawHealthbar(8, 55 - 8, &battleAllies[1], HB2, 1);
    } else {
        shadowOAM[ALLY2_B].attr0 = (2 << 8);
        shadowOAM[HB2].attr0 = (2 << 8);
    }
    if (battleAllies[2].exists && battleAllies[2].hp > 0) {
        shadowOAM[ALLY3_B].attr0 = (95 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ALLY3_B].attr1 = (8 & 0x1FF) | (2 << 14);
        shadowOAM[ALLY3_B].attr2 = battleAllies[2].tileid;
        drawHealthbar(8, 95 - 8, &battleAllies[2], HB3, 2);
    } else {
        shadowOAM[ALLY3_B].attr0 = (2 << 8);
        shadowOAM[HB3].attr0 = (2 << 8);
    }
    if (battleAllies[3].exists && battleAllies[3].hp > 0) {
        shadowOAM[ALLY4_B].attr0 = (135 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ALLY4_B].attr1 = (8 & 0x1FF) | (2 << 14);
        shadowOAM[ALLY4_B].attr2 = battleAllies[3].tileid;
        drawHealthbar(8, 135 - 8, &battleAllies[3], HB4, 3);
    } else {
        shadowOAM[ALLY4_B].attr0 = (2 << 8);
        shadowOAM[HB4].attr0 = (2 << 8);
    }


    if (battleOpponents[0].exists && battleOpponents[0].hp > 0) {
        shadowOAM[ENEMY1_B].attr0 = (15 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ENEMY1_B].attr1 = (200 & 0x1FF) | (2 << 14) | (1 << 12);
        shadowOAM[ENEMY1_B].attr2 = battleOpponents[0].tileid;
        drawHealthbar(200, 15 - 8, &battleOpponents[0], HB5, 4);
    } else {
        shadowOAM[ENEMY1_B].attr0 = (2 << 8);
        shadowOAM[HB5].attr0 = (2 << 8);
    }
    if (battleOpponents[1].exists && battleOpponents[1].hp > 0) {
        shadowOAM[ENEMY2_B].attr0 = (55 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ENEMY2_B].attr1 = (200 & 0x1FF) | (2 << 14) | (1 << 12);
        shadowOAM[ENEMY2_B].attr2 = battleOpponents[1].tileid;
        drawHealthbar(200, 55 - 8, &battleOpponents[1], HB6, 5);
    } else {
        shadowOAM[ENEMY2_B].attr0 = (2 << 8);
        shadowOAM[HB6].attr0 = (2 << 8);
    }
    if (battleOpponents[2].exists && battleOpponents[2].hp > 0) {
        shadowOAM[ENEMY3_B].attr0 = (95 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ENEMY3_B].attr1 = (200 & 0x1FF) | (2 << 14) | (1 << 12);
        shadowOAM[ENEMY3_B].attr2 = battleOpponents[2].tileid;
        drawHealthbar(200, 95 - 8, &battleOpponents[2], HB7, 6);
    } else {
        shadowOAM[ENEMY3_B].attr0 = (2 << 8);
        shadowOAM[HB7].attr0 = (2 << 8);
    }
    if (battleOpponents[3].exists && battleOpponents[3].hp > 0) {
        shadowOAM[ENEMY4_B].attr0 = (135 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
        shadowOAM[ENEMY4_B].attr1 = (200 & 0x1FF) | (2 << 14) | (1 << 12);
        shadowOAM[ENEMY4_B].attr2 = battleOpponents[3].tileid;
        drawHealthbar(200, 135 - 8, &battleOpponents[3], HB8, 7);
    } else {
        shadowOAM[ENEMY4_B].attr0 = (2 << 8);
        shadowOAM[HB8].attr0 = (2 << 8);
    }
}


void eraseAllText() {
    for (int i = TEXT_IDX; i < 128; i++) {
        shadowOAM[i].attr0 = (2 << 8);
    }
    lettersActive = 0;
}


void drawText(char* str, int textboxX, int textboxY, int textboxWidth, int textboxHeight) {

    int rightLimit = textboxX + textboxWidth;
    int bottomLimit = textboxY + textboxHeight;
    int cursorx = textboxX;
    int cursory = textboxY;
    while(*str != '\0') {

        if (*str == '\n') {
            cursory += 8;
            cursorx = textboxX;
        } else {

            if (*str != ' ') {
                int idx = TEXT_IDX + lettersActive;

                if (idx >= 128) {
                    return;
                }
                shadowOAM[idx].attr0 = (cursory & 0xFF) | (0 << 8) | (1 << 13);
                shadowOAM[idx].attr1 = (cursorx & 0x1FF) | (0 << 14);
                shadowOAM[idx].attr2 = text_tile_lkup[*str - '!'];
                lettersActive++;
            }

            cursorx += 6;
            if (cursorx + 6 >= rightLimit) {
                cursory += 8;
                cursorx = textboxX;
            }
        }

        if (cursory >= bottomLimit) {
            return;
        }

        str++;
    }
}


void setTopText(char* str) {
    drawText(str, 59, 11, (121), (3 * 8));
}


void setBottomText(char* str) {
    drawText(str, 59, 123, (121), (3 * 8));
}
