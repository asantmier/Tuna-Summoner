# 1 "world.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "world.c"
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 1 3
# 10 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 11 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 1 3
# 10 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/newlib.h" 1 3
# 14 "/opt/devkitpro/devkitARM/arm-none-eabi/include/newlib.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_newlib_version.h" 1 3
# 15 "/opt/devkitpro/devkitARM/arm-none-eabi/include/newlib.h" 2 3
# 11 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/config.h" 1 3



# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 5 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/config.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/features.h" 1 3
# 6 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/config.h" 2 3
# 12 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 2 3
# 12 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3




# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 209 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4

# 209 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 321 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 17 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3

# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 1 3
# 13 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/_ansi.h" 1 3
# 14 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 143 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 15 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 1 3
# 24 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_types.h" 1 3



# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 1 3
# 41 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 55 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 77 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;
# 103 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
# 134 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 160 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 182 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;
# 200 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
# 214 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 5 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/_types.h" 2 3


typedef __int64_t _off_t;


typedef __int64_t _fpos_t;


typedef __uint32_t __ino_t;


typedef __uint32_t __dev_t;
# 25 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/lock.h" 1 3




# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdint.h" 1 3 4
# 9 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdint.h" 3 4
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 1 3 4
# 13 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_intsup.h" 1 3 4
# 35 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_intsup.h" 3 4
       
       
       
       
       
       
       
# 187 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_intsup.h" 3 4
       
       
       
       
       
       
       
# 14 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 2 3 4
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_stdint.h" 1 3 4
# 20 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_stdint.h" 3 4
typedef __int8_t int8_t ;



typedef __uint8_t uint8_t ;







typedef __int16_t int16_t ;



typedef __uint16_t uint16_t ;







typedef __int32_t int32_t ;



typedef __uint32_t uint32_t ;







typedef __int64_t int64_t ;



typedef __uint64_t uint64_t ;






typedef __intmax_t intmax_t;




typedef __uintmax_t uintmax_t;




typedef __intptr_t intptr_t;




typedef __uintptr_t uintptr_t;
# 15 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 2 3 4






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;




typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;




typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;




typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
# 51 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
# 61 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
# 71 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 81 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
# 10 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stdint.h" 2 3 4
# 6 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/lock.h" 2 3

typedef int32_t _LOCK_T;

struct __lock_t {
 _LOCK_T lock;
 uint32_t thread_tag;
 uint32_t counter;
};

typedef struct __lock_t _LOCK_RECURSIVE_T;

extern void __libc_lock_init(_LOCK_T *lock);
extern void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_close(_LOCK_T *lock);
extern void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_acquire(_LOCK_T *lock);
extern void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_release(_LOCK_T *lock);
extern void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock);


extern int __libc_lock_try_acquire(_LOCK_T *lock);
extern int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock);
# 26 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;
# 50 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef int __pid_t;







typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;
# 88 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;
# 129 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef unsigned int __size_t;
# 145 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef signed int _ssize_t;
# 156 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;


# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 350 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 160 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;






typedef unsigned long __clock_t;






typedef __int_least64_t __time_t;





typedef unsigned long __clockid_t;


typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;




typedef char * __va_list;
# 16 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 38 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _reent;

struct __locale_t;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 93 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 117 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 181 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (*_read) (struct _reent *, void *,
        char *, int);
  int (*_write) (struct _reent *, void *,
         const char *,
         int);
  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  int (*_close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 287 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 319 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 610 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];


  int _unspecified_locale_info;
  struct __locale_t *_locale;

  int __sdidinit;

  void (*__cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**(_sig_func))(int);




  struct _glue __sglue;

  __FILE __sf[3];

  void *deviceData;
};
# 817 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);





  struct _reent * __getreent (void);
# 19 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/cdefs.h" 1 3
# 47 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/cdefs.h" 3
# 1 "/opt/devkitpro/devkitARM/lib/gcc/arm-none-eabi/9.1.0/include/stddef.h" 1 3 4
# 48 "/opt/devkitpro/devkitARM/arm-none-eabi/include/sys/cdefs.h" 2 3
# 20 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/opt/devkitpro/devkitARM/arm-none-eabi/include/machine/stdlib.h" 1 3
# 21 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 33 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;




typedef int (*__compar_fn_t) (const void *, const void *);







int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((__noreturn__));
int abs (int);





int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void *__key,
         const void *__base,
         size_t __nmemb,
         size_t __size,
         __compar_fn_t _compar);
void *calloc(size_t, size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__))
      __attribute__((__alloc_size__(1, 2))) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((__noreturn__));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);




long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void *malloc(size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(1))) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int _mbtowc_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);
size_t _wcstombs_r (struct _reent *, char *restrict, const wchar_t *restrict, size_t, _mbstate_t *);
# 134 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__deprecated__("the use of `mktemp' is dangerous; use `mkstemp' instead")));
void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand (void);
void *realloc(void *, size_t) __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(2))) ;
# 156 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
void srand (unsigned __seed);
double strtod (const char *restrict __n, char **restrict __end_PTR);
double _strtod_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR);

float strtof (const char *restrict __n, char **restrict __end_PTR);







long strtol (const char *restrict __n, char **restrict __end_PTR, int __base);
long _strtol_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long strtoul (const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);
# 188 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
int system (const char *__string);
# 199 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
void _Exit (int __status) __attribute__ ((__noreturn__));




int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);



int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);
# 221 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
char * __itoa (int, char *, int);
char * __utoa (unsigned, char *, int);
# 260 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
long long atoll (const char *__nptr);

long long _atoll_r (struct _reent *, const char *__nptr);

long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *restrict __n, char **restrict __end_PTR, int __base);

long long _strtoll_r (struct _reent *, const char *restrict __n, char **restrict __end_PTR, int __base);

unsigned long long strtoull (const char *restrict __n, char **restrict __end_PTR, int __base);

unsigned long long _strtoull_r (struct _reent *, const char *restrict __n, char **restrict __end_PTR, int __base);
# 281 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
int _unsetenv_r (struct _reent *, const char *__string);







char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);
# 319 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3
extern long double _strtold_r (struct _reent *, const char *restrict, char **restrict);

extern long double strtold (const char *restrict, char **restrict);
# 336 "/opt/devkitpro/devkitARM/arm-none-eabi/include/stdlib.h" 3

# 2 "world.c" 2
# 1 "mode0.h" 1





# 5 "mode0.h"
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
# 60 "mode0.h"
typedef int fp256;

extern fp256 bg2xOff, bg2yOff;


typedef struct {
    short pa, pb;
    short pc, pd;
    int dx, dy;
} BG_AFFINE;




extern const BG_AFFINE bg_aff_default;
# 84 "mode0.h"
extern volatile unsigned short *videoBuffer;
# 105 "mode0.h"
typedef struct {
    u16 tileimg[8192];
} charblock;


typedef struct {
    u16 tilemap[1024];
} screenblock;



void setPixel3(int col, int row, unsigned short color);
void drawRect3(int col, int row, int width, int height, volatile unsigned short color);
void fillScreen3(volatile unsigned short color);
void drawImage3(int col, int row, int width, int height, const unsigned short *image);
void drawFullscreenImage3(const unsigned short *image);


void setPixel4(int col, int row, unsigned char colorIndex);
void drawRect4(int col, int row, int width, int height, volatile unsigned char colorIndex);
void fillScreen4(volatile unsigned char colorIndex);
void drawImage4(int col, int row, int width, int height, const unsigned short *image);
void drawFullscreenImage4(const unsigned short *image);


void waitForVBlank();
void flipPage();




typedef struct {
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
} OBJ_ATTR;



extern OBJ_ATTR shadowOAM[];
# 177 "mode0.h"
void hideSprites();






typedef struct {
    int worldRow;
    int worldCol;
    int rdel;
    int cdel;
    int width;
    int height;
    int aniCounter;
    int aniState;
    int prevAniState;
    int curFrame;
    int numFrames;
    int hide;
} SPRITE;
# 217 "mode0.h"
extern unsigned short oldButtons;
extern unsigned short buttons;
# 227 "mode0.h"
typedef volatile struct {
    volatile const void *src;
    volatile void *dst;
    volatile unsigned int cnt;
} DMA;


extern DMA *dma;
# 267 "mode0.h"
void DMANow(int channel, volatile const void *src, volatile void *dst, unsigned int cnt);
# 303 "mode0.h"
typedef void (*ihp)(void);
# 322 "mode0.h"
int collision(int colA, int rowA, int widthA, int heightA, int colB, int rowB, int widthB, int heightB);
int collisionCheck(unsigned char *collisionMap, int mapWidth, int x, int y, int width, int height);
# 3 "world.c" 2
# 1 "print.h" 1
# 36 "print.h"
void mgba_printf_level(int level, const char* ptr, ...);
void mgba_printf(const char* string, ...);
void mgba_break(void);
uint8_t mgba_open(void);
void mgba_close(void);
# 4 "world.c" 2
# 1 "world.h" 1




# 1 "game.h" 1




# 1 "moves.h" 1





enum { OPPONENT, ALLY };

typedef struct tag_move {
    char text[10];
    char flavorText[61];
    int damage;
    int hitAll;
    int targeting;
    int healing;
} MOVE;

extern MOVE MOVE_SLASH;
extern MOVE MOVE_BLAST;
extern MOVE MOVE_HEAL;
# 33 "moves.h"
extern MOVE MOVE_NIBBLE;
extern MOVE MOVE_BITE;
extern MOVE MOVE_STRIKE;
extern MOVE MOVE_SLASH;

extern MOVE MOVE_FLAIL;
extern MOVE MOVE_PUFFUP;
extern MOVE MOVE_WAVE;

extern MOVE MOVE_REGEN;
extern MOVE MOVE_RESOLVE;
extern MOVE MOVE_SHEAL;
extern MOVE MOVE_LHEAL;
extern MOVE MOVE_SHEALBURST;
extern MOVE MOVE_LHEALBURST;

extern MOVE MOVE_DASH;
extern MOVE MOVE_TRANSCEND;

extern MOVE MOVE_TORPEDO1;
extern MOVE MOVE_TORPEDO2;
extern MOVE MOVE_SHIELD1;
extern MOVE MOVE_SHIELD2;
extern MOVE MOVE_BLAST1;
extern MOVE MOVE_BLAST2;
extern MOVE MOVE_DEATHRAY;
extern MOVE MOVE_BRUH;

extern MOVE MOVE_NONE;
# 6 "game.h" 2

extern int submarineMaxHp;
extern int submarineHp;

extern int gameVictory;


enum { FISH, SHARK, ANGLER, PUFFER, BARRACUDA, BOSS };




typedef struct tag_combatant {
    char name[10];
    int exists;
    int maxHp;
    int hp;
    int numMoves;
    MOVE* moves[6];
    int tileid;
} COMBATANT;


extern COMBATANT CBT_FISH;
extern COMBATANT CBT_SHARK;
extern COMBATANT CBT_ANGLER;
extern COMBATANT CBT_PUFFER;
extern COMBATANT CBT_BARRACUDA;
extern COMBATANT CBT_GOD;
extern COMBATANT CBT_SUBMARINE;
extern COMBATANT CBT_NONE;
# 47 "game.h"
extern COMBATANT battleAllies[4];
extern COMBATANT battleOpponents[4];


extern int cheater;


void initGame();
void initParty();


int tilesRed(int tile1, int hp, int maxHp, int segments);
# 6 "world.h" 2


enum {
    PLAYER_IDX = 0, BULLET1, BULLET2, BULLET3, BULLET4, BULLET5, ENEMY1, ENEMY2, ENEMY3, ENEMY4, ENEMY5, ENEMY6,
    ENEMY7, ENEMY8, ENEMY9, ENEMY10, HEALTHBAR1, HEALTHBAR2, HEALTHBAR3, HEALTHBAR4, HEALTHBAR5, HEALTHBAR6,
    HEALTHBAR7, HEALTHBAR8, MINE1, MINE2, MINE3, MINE4, MINE5, MINE6, MINE7, MINE8, MINE9, MINE10, MINE11, MINE12,
    MINE13, MINE14, MINE15, MINE16, MINE17, MINE18, MINE19, MINE20, PICKUP1, PICKUP2, PICKUP3, PICKUP4, PICKUP5
};


typedef int fp64;
# 54 "world.h"
enum { LEFT, RIGHT };

enum { PASSIVE, NEUTRAL, HOSTILE };

enum { UPGRADE_TORP, UPGRADE_BLAST, UPGRADE_SHIELD, RESTORE_HP };


typedef struct tag_player {
    fp64 int_x, int_y;
    int x, y;
    fp64 dx, dy;
    int width, height;
    int facing;
} PLAYER;

typedef struct tag_bullet {
    fp64 int_x, int_y;
    int x, y;
    fp64 dx, dy;
    int width, height;
    int active;
    int spriteIdx;
} BULLET;

typedef struct tag_enemy {
    fp64 int_x, int_y;
    int x, y;
    fp64 dx, dy;
    int width, height;
    int active;
    int ai;
    int type;
} ENEMY;

typedef struct tag_mine {
    fp64 int_x, int_y;
    int x, y;
    fp64 dx, dy;
    int width, height;
    int active;
    int damage;
} MINE;

typedef struct tag_pickup {
    fp64 int_x, int_y;
    int x, y;
    int width, height;
    int active;
    int effect;
} PICKUP;

typedef struct tag_level {

    ENEMY enemyList[60];
    MINE mineList[60];
    PICKUP pickupList[10];
} LEVEL;


LEVEL levels[1];


extern PLAYER player;
extern BULLET bullets[5];
extern ENEMY enemies[60];
extern MINE mines[60];
extern PICKUP pickups[10];


extern int doBattle;
extern int opponentIdx;


extern int drawnEnemies;
extern int drawnMines;


void returnFromBattle(int victory);


void initWorld();
void initPlayer();
void initBullets();
void initEnemies();
void initMines();
void initPickups();


void updateWorld();
void updatePlayer();
void updateBullet(BULLET* bullet);
void updateEnemy(ENEMY* enemy);
void updateMine(MINE* mine);
void updatePickup(PICKUP* pickup);


void freeEnemySprites();
void drawEnemy(ENEMY* enemy);
void freeMineSprites();
void drawMine(MINE* mine);
void freePickupSprites();
void drawPickup(PICKUP* pickup);


void updateHealthBar();
# 5 "world.c" 2
# 1 "world1collision.h" 1
# 21 "world1collision.h"
extern const unsigned short world1collisionBitmap[524288];


extern const unsigned short world1collisionPal[256];
# 6 "world.c" 2
# 1 "sound.h" 1
void setupSounds();
void playSoundA(const signed char* sound, int length, int loops, int offset);
void playSoundB(const signed char* sound, int length, int loops);

void setupSoundInterrupts();
void soundInterruptHandler();

void pauseSound();
void unpauseSound();
void stopSound();
# 49 "sound.h"
typedef struct{
    const signed char* data;
    int length;
    int frequency;
    int isPlaying;
    int loops;
    int duration;
    int priority;
    int vBlankCount;
} SOUND;

SOUND soundA;
SOUND soundB;
# 7 "world.c" 2
# 1 "shootsfx.h" 1


extern const unsigned int shootsfx_sampleRate;
extern const unsigned int shootsfx_length;
extern const signed char shootsfx_data[];
# 8 "world.c" 2
# 1 "boomsfx.h" 1


extern const unsigned int boomsfx_sampleRate;
extern const unsigned int boomsfx_length;
extern const signed char boomsfx_data[];
# 9 "world.c" 2
# 1 "fanfaresfx.h" 1


extern const unsigned int fanfaresfx_sampleRate;
extern const unsigned int fanfaresfx_length;
extern const signed char fanfaresfx_data[];
# 10 "world.c" 2

unsigned char* collisionMap = (unsigned char*) world1collisionBitmap;

PLAYER player;
BULLET bullets[5];
ENEMY enemies[60];
MINE mines[60];
PICKUP pickups[10];



LEVEL levels[1] = {
    {
        {
            {.int_x=32*64, .int_y=160*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=184*64, .int_y=176*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=64*64, .int_y=336*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=256*64, .int_y=352*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=336*64, .int_y=336*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=416*64, .int_y=184*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=337*64, .int_y=128*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=440*64, .int_y=72*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=608*64, .int_y=88*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=624*64, .int_y=136*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=744*64, .int_y=120*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=832*64, .int_y=136*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=705*64, .int_y=184*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=848*64, .int_y=312*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=648*64, .int_y=321*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=776*64, .int_y=472*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=656*64, .int_y=512*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=753*64, .int_y=536*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=648*64, .int_y=624*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=817*64, .int_y=624*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=BARRACUDA},
            {.int_x=704*64, .int_y=697*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=936*64, .int_y=672*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=976*64, .int_y=568*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=832*64, .int_y=760*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=PUFFER},
            {.int_x=776*64, .int_y=808*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=ANGLER},
            {.int_x=880*64, .int_y=952*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=544*64, .int_y=960*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=424*64, .int_y=960*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=560*64, .int_y=664*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=PUFFER},
            {.int_x=528*64, .int_y=496*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=546*64, .int_y=400*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=FISH},
            {.int_x=392*64, .int_y=520*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=472*64, .int_y=553*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=449*64, .int_y=625*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=ANGLER},
            {.int_x=329*64, .int_y=569*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=360*64, .int_y=648*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=BARRACUDA},
            {.int_x=360*64, .int_y=696*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=272*64, .int_y=647*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=PUFFER},
            {.int_x=240*64, .int_y=584*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=SHARK},
            {.int_x=184*64, .int_y=544*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=ANGLER},
            {.int_x=96*64, .int_y=600*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=BARRACUDA},
            {.int_x=32*64, .int_y=556*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=BARRACUDA},
            {.int_x=68*64, .int_y=464*64, .width=16, .height=8, .active=1, .ai=PASSIVE, .type=PUFFER},
            {.int_x=168*64, .int_y=928*64, .width=32, .height=16, .active=1, .ai=PASSIVE, .type=BOSS},
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        },
        {
            { .int_x = 152 * 64, .int_y = 352 * 64, .active = 1, .damage = 10 },
            { .int_x = 176 * 64, .int_y = 352 * 64, .active = 1, .damage = 10 },
            { .int_x = 200 * 64, .int_y = 352 * 64, .active = 1, .damage = 10 },
            { .int_x = 256 * 64, .int_y = 328 * 64, .active = 1, .damage = 10 },
            { .int_x = 392 * 64, .int_y = 328 * 64, .active = 1, .damage = 10 },
            { .int_x = 464 * 64, .int_y = 312 * 64, .active = 1, .damage = 10 },
            { .int_x = 520 * 64, .int_y = 184 * 64, .active = 1, .damage = 10 },
            { .int_x = 488 * 64, .int_y = 216 * 64, .active = 1, .damage = 10 },
            { .int_x = 472 * 64, .int_y = 216 * 64, .active = 1, .damage = 10 },
            { .int_x = 736 * 64, .int_y = 336 * 64, .active = 1, .damage = 10 },
            { .int_x = 752 * 64, .int_y = 328 * 64, .active = 1, .damage = 10 },
            { .int_x = 768 * 64, .int_y = 334 * 64, .active = 1, .damage = 10 },
            { .int_x = 784 * 64, .int_y = 336 * 64, .active = 1, .damage = 10 },
            { .int_x = 800 * 64, .int_y = 336 * 64, .active = 1, .damage = 10 },
            { .int_x = 816 * 64, .int_y = 336 * 64, .active = 1, .damage = 10 },
            { .int_x = 832 * 64, .int_y = 328 * 64, .active = 1, .damage = 10 },
            { .int_x = 848 * 64, .int_y = 328 * 64, .active = 1, .damage = 10 },
            { .int_x = 864 * 64, .int_y = 328 * 64, .active = 1, .damage = 10 },
            { .int_x = 792 * 64, .int_y = 488 * 64, .active = 1, .damage = 10 },
            { .int_x = 960 * 64, .int_y = 416 * 64, .active = 1, .damage = 10 },
            { .int_x = 976 * 64, .int_y = 416 * 64, .active = 1, .damage = 10 },
            { .int_x = 960 * 64, .int_y = 376 * 64, .active = 1, .damage = 10 },
            { .int_x = 1000 * 64, .int_y = 376 * 64, .active = 1, .damage = 10 },
            { .int_x = 976 * 64, .int_y = 344 * 64, .active = 1, .damage = 10 },
            { .int_x = 992 * 64, .int_y = 312 * 64, .active = 1, .damage = 10 },
            { .int_x = 968 * 64, .int_y = 280 * 64, .active = 1, .damage = 10 },
            { .int_x = 984 * 64, .int_y = 256 * 64, .active = 1, .damage = 10 },
            { .int_x = 1000 * 64, .int_y = 240 * 64, .active = 1, .damage = 10 },
            { .int_x = 976 * 64, .int_y = 208 * 64, .active = 1, .damage = 10 },
            { .int_x = 984 * 64, .int_y = 200 * 64, .active = 1, .damage = 10 },
            { .int_x = 968 * 64, .int_y = 160 * 64, .active = 1, .damage = 10 },
            { .int_x = 992 * 64, .int_y = 128 * 64, .active = 1, .damage = 10 },
            { .int_x = 968 * 64, .int_y = 112 * 64, .active = 1, .damage = 10 },
            { .int_x = 984 * 64, .int_y = 88 * 64, .active = 1, .damage = 10 },
            { .int_x = 1000 * 64, .int_y = 88 * 64, .active = 1, .damage = 10 },
            { .int_x = 752 * 64, .int_y = 760 * 64, .active = 1, .damage = 10 },
            { .int_x = 704 * 64, .int_y = 808 * 64, .active = 1, .damage = 10 },
            { .int_x = 648 * 64, .int_y = 744 * 64, .active = 1, .damage = 10 },
            { .int_x = 672 * 64, .int_y = 808 * 64, .active = 1, .damage = 10 },
            { .int_x = 624 * 64, .int_y = 784 * 64, .active = 1, .damage = 10 },
            { .int_x = 600 * 64, .int_y = 760 * 64, .active = 1, .damage = 10 },
            { .int_x = 592 * 64, .int_y = 824 * 64, .active = 1, .damage = 10 },
            { .int_x = 560 * 64, .int_y = 808 * 64, .active = 1, .damage = 10 },
            { .int_x = 520 * 64, .int_y = 792 * 64, .active = 1, .damage = 10 },
            { .int_x = 504 * 64, .int_y = 824 * 64, .active = 1, .damage = 10 },
            { .int_x = 472 * 64, .int_y = 768 * 64, .active = 1, .damage = 10 },
            { .int_x = 448 * 64, .int_y = 816 * 64, .active = 1, .damage = 10 },
            { .int_x = 432 * 64, .int_y = 760 * 64, .active = 1, .damage = 10 },
            { .int_x = 360 * 64, .int_y = 816 * 64, .active = 1, .damage = 10 },
            { .int_x = 336 * 64, .int_y = 808 * 64, .active = 1, .damage = 10 },
            { .int_x = 472 * 64, .int_y = 672 * 64, .active = 1, .damage = 10 },
            { .int_x = 272 * 64, .int_y = 704 * 64, .active = 1, .damage = 10 },
            { .int_x = 200 * 64, .int_y = 616 * 64, .active = 1, .damage = 10 },
            { .int_x = 448 * 64, .int_y = 456 * 64, .active = 1, .damage = 10 },
            { .int_x = 448 * 64, .int_y = 424 * 64, .active = 1, .damage = 10 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        },
        {
            { .int_x = 768 * 64, .int_y = 8 * 64, .active = 1, .effect = UPGRADE_TORP },
            { .int_x = 760 * 64, .int_y = 808 * 64, .active = 1, .effect = UPGRADE_SHIELD },
            { .int_x = 20 * 64, .int_y = 464 * 64, .active = 1, .effect = UPGRADE_BLAST },
            { .int_x = 904 * 64, .int_y = 24 * 64, .active = 1, .effect = RESTORE_HP },
            { .int_x = 432 * 64, .int_y = 945 * 64, .active = 1, .effect = RESTORE_HP },
            { .int_x = 568 * 64, .int_y = 700 * 64, .active = 1, .effect = RESTORE_HP },
            { .int_x = 688 * 64, .int_y = 960 * 64, .active = 1, .effect = RESTORE_HP },
            { 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 },
        }
    }
};

int level = 0;
int doBattle = 0;
int opponentIdx;
int drawnEnemies = 0;
int drawnMines = 0;
int drawnPickups = 0;

int enemyFrameCounter = 0;
int enemyAniFrame = 0;
int mineFrameCounter = 0;
int mineAniFrame = 0;


void returnFromBattle(int victory) {
    if (victory) {

    }

        doBattle = 0;
        enemies[opponentIdx].active = 0;



}


void initWorld() {
    level = 0;
    doBattle = 0;

    initPlayer();
    initBullets();
    initEnemies();
    initMines();
    initPickups();
}


void initPlayer() {
    player.int_x = 128 * 64;
    player.int_y = 32 * 64;
    player.x = 128;
    player.y = 32;
    player.dx = 0;
    player.dy = 0;
    player.width = 16;
    player.height = 8;
    player.facing = RIGHT;
}


void initBullets() {
    for (int i = 0; i < 5; i++) {
        bullets[i].int_x = 0;
        bullets[i].int_y = 0;
        bullets[i].x = 0;
        bullets[i].y = 0;
        bullets[i].dx = 0;
        bullets[i].dy = 0;
        bullets[i].width = 2;
        bullets[i].height = 1;
        bullets[i].active = 0;
        bullets[i].spriteIdx = BULLET1 + i;
    }
}


void initEnemies() {
    for (int i = 0; i < 60; i++) {
        enemies[i].int_x = levels[level].enemyList[i].int_x;
        enemies[i].int_y = levels[level].enemyList[i].int_y;
        enemies[i].x = ((enemies[i].int_x) >> 6) - bg2xOff;
        enemies[i].y = ((enemies[i].int_y) >> 6) - bg2yOff;
        enemies[i].dx = levels[level].enemyList[i].dx;
        enemies[i].dy = levels[level].enemyList[i].dy;
        enemies[i].width = levels[level].enemyList[i].width;
        enemies[i].height = levels[level].enemyList[i].height;
        enemies[i].active = levels[level].enemyList[i].active;
        enemies[i].ai = levels[level].enemyList[i].ai;
        enemies[i].type = levels[level].enemyList[i].type;
    }
}


void initMines() {
    for (int i = 0; i < 60; i++) {
        mines[i].int_x = levels[level].mineList[i].int_x;
        mines[i].int_y = levels[level].mineList[i].int_y;
        mines[i].x = ((mines[i].int_x) >> 6) - bg2xOff;
        mines[i].y = ((mines[i].int_y) >> 6) - bg2yOff;
        mines[i].dx = levels[level].mineList[i].dx;
        mines[i].dy = levels[level].mineList[i].dy;


        mines[i].width = 8;
        mines[i].height = 8;
        mines[i].active = levels[level].mineList[i].active;
        mines[i].damage = levels[level].mineList[i].damage;
    }
}


void initPickups() {
    for (int i = 0; i < 10; i++) {
        pickups[i].int_x = levels[level].pickupList[i].int_x;
        pickups[i].int_y = levels[level].pickupList[i].int_y;
        pickups[i].x = ((pickups[i].int_x) >> 6) - bg2xOff;
        pickups[i].y = ((pickups[i].int_y) >> 6) - bg2yOff;
        pickups[i].width = 8;
        pickups[i].height = 8;
        pickups[i].active = levels[level].pickupList[i].active;
        pickups[i].effect = levels[level].pickupList[i].effect;
    }
}


void doCollision() {
    for (int i = 0; i < 60; i++) {
        if (enemies[i].active) {
            if (collision(player.int_x, player.int_y, ((player.width) << 6), ((player.height) << 6),
            enemies[i].int_x, enemies[i].int_y, ((enemies[i].width) << 6), ((enemies[i].height) << 6))) {

                doBattle = 1;
                opponentIdx = i;
                return;
            }
            for (int j = 0; j < 5; j++) {
                if (bullets[j].active) {
                    if (collision(bullets[j].int_x, bullets[j].int_y, ((bullets[j].width) << 6), ((bullets[j].height) << 6),
                    enemies[i].int_x, enemies[i].int_y, ((enemies[i].width) << 6), ((enemies[i].height) << 6))) {

                        bullets[j].active = 0;
                        shadowOAM[bullets[j].spriteIdx].attr0 = (2 << 8) | (1 << 13);

                        doBattle = 1;
                        opponentIdx = i;
                        return;
                    }
                }
            }
        }
    }
    for (int i = 0; i < 60; i++) {
        if (mines[i].active) {
            if (collision(player.int_x, player.int_y, ((player.width) << 6), ((player.height) << 6),
            mines[i].int_x, mines[i].int_y, ((mines[i].width) << 6), ((mines[i].height) << 6))) {

                mines[i].active = 0;
                submarineHp -= mines[i].damage;
                playSoundB(boomsfx_data, boomsfx_length, 0);
            }
        }
    }
    for (int i = 0; i < 10; i++) {
        if (pickups[i].active) {
            if (collision(player.int_x, player.int_y, ((player.width) << 6), ((player.height) << 6),
            pickups[i].int_x, pickups[i].int_y, ((pickups[i].width) << 6), ((pickups[i].height) << 6))) {
                pickups[i].active = 0;
                playSoundB(fanfaresfx_data, fanfaresfx_length, 0);
                switch (pickups[i].effect)
                {
                case UPGRADE_TORP:
                    battleAllies[0].moves[0] = &MOVE_TORPEDO2;
                    break;
                case UPGRADE_BLAST:
                    battleAllies[0].moves[2] = &MOVE_BLAST2;
                    break;
                case UPGRADE_SHIELD:
                    battleAllies[0].moves[1] = &MOVE_SHIELD2;
                    break;
                case RESTORE_HP:
                    submarineHp += 50;
                    if (submarineHp > submarineMaxHp) submarineHp = submarineMaxHp;
                    for (int j = 0; j < 4; j++) {
                        battleAllies[j].hp = battleAllies[j].maxHp;
                    }
                    break;
                }
            }
        }
    }




}


void updateWorld() {

    if (enemyFrameCounter > 20) {
        enemyAniFrame++;
        enemyAniFrame %= 3;
        enemyFrameCounter = 0;
    }
    enemyFrameCounter++;

    if (mineFrameCounter > 20) {
        mineAniFrame++;
        mineAniFrame %= 3;
        mineFrameCounter = 0;
    }
    mineFrameCounter++;
    updatePlayer();
    for (int i = 0; i < 5; i++) {
        if (bullets[i].active) {
            updateBullet(&bullets[i]);
        }
    }
    freeEnemySprites();
    for (int i = 0; i < 60; i++) {
        if (enemies[i].active) {
            updateEnemy(&enemies[i]);
        }
    }
    freeMineSprites();
    for (int i = 0; i < 60; i++) {
        if (mines[i].active) {
            updateMine(&mines[i]);
        }
    }
    freePickupSprites();
    for (int i = 0; i < 10; i++) {
        if (pickups[i].active) {
            updatePickup(&pickups[i]);
        }
    }

    doCollision();

    updateHealthBar();
}


void movePlayer() {


    fp64 rdx = player.dx;
    fp64 rdy = player.dy;


    if (player.int_x + player.dx < 0) {
        rdx = player.dx - (player.int_x + player.dx);
    } else if (player.int_x + player.dx + ((player.width) << 6) > ((1024) << 6)) {
        rdx = player.dx - (player.int_x + player.dx + ((player.width) << 6) - ((1024) << 6));
    }
    if (player.int_y + player.dy < 0) {
        rdy = player.dy - (player.int_y + player.dy);
    } else if (player.int_y + ((player.height) << 6) > ((1024) << 6)) {
        rdy = player.dy - (player.int_y + player.dy + ((player.height) << 6) - ((1024) << 6));
    }



    if (collisionCheck(collisionMap, 1024, ((player.int_x + rdx) >> 6), ((player.int_y + rdy) >> 6), player.width, player.height) > 0) {
        if (collisionCheck(collisionMap, 1024, ((player.int_x + ((rdx * 3) / 4)) >> 6), ((player.int_y + ((rdy * 3) / 4)) >> 6), player.width, player.height) > 0) {
            if (collisionCheck(collisionMap, 1024, ((player.int_x + (rdx / 2)) >> 6), ((player.int_y + (rdy / 2)) >> 6), player.width, player.height) > 0) {
                if (collisionCheck(collisionMap, 1024, ((player.int_x + (rdx / 4)) >> 6), ((player.int_y + (rdy / 4)) >> 6), player.width, player.height) > 0) {

                    rdx = 0;
                    rdy = 0;
                } else {

                    rdx /= 4;
                    rdy /= 4;


                    player.int_x = ((((player.int_x + rdx) >> 6)) << 6);
                    player.int_y = ((((player.int_y + rdy) >> 6)) << 6);
                }
            } else {

                rdx /= 2;
                rdy /= 2;
                player.int_x = ((((player.int_x + rdx) >> 6)) << 6);
                player.int_y = ((((player.int_y + rdy) >> 6)) << 6);
            }
        } else {

            rdx = (rdx * 3) / 4;
            rdy = (rdy * 3) / 4;
            player.int_x = ((((player.int_x + rdx) >> 6)) << 6);
            player.int_y = ((((player.int_y + rdy) >> 6)) << 6);
        }
    } else {

        player.int_x += rdx;
        player.int_y += rdy;
    }



    if (abs(rdx) < abs(player.dx)) {
        player.dx = 0;

    }
    if (abs(rdy) < abs(player.dy)) {
        player.dy = 0;
    }


    player.x = ((player.int_x) >> 6) - bg2xOff;
    player.y = ((player.int_y) >> 6) - bg2yOff;

    if (player.x < 79) {

        if (bg2xOff > 0) {
            int xDiff = 79 - player.x;
            if (xDiff <= bg2xOff) {
                player.x = 79;
                bg2xOff -= xDiff;
            } else {
                int netDx = xDiff - bg2xOff;
                bg2xOff -= xDiff - netDx;
                player.x -= netDx;
            }
        }
    }
    if (player.x + player.width > 159) {
        if (bg2xOff < 1024 - 240) {
            int xDiff = player.x + player.width - 159;
            if (xDiff + bg2xOff <= 1024 - 240) {
                player.x = 159 - player.width;
                bg2xOff += xDiff;
            } else {
                int netDx = (xDiff + bg2xOff + 240) - 1024;
                bg2xOff += xDiff - netDx;
                player.x += netDx;
            }
        }
    }
    if (player.y < 52) {
        if (bg2yOff > 0) {
            int yDiff = 52 - player.y;
            if (yDiff <= bg2yOff) {
                player.y = 52;
                bg2yOff -= yDiff;
            } else {
                int netDy = yDiff - bg2yOff;
                bg2yOff -= yDiff - netDy;
                player.y -= netDy;
            }
        }
    }
    if (player.y + player.height > 105) {
        if (bg2yOff < 1024 - 160) {
            int yDiff = player.y + player.height - 105;
            if (yDiff + bg2yOff <= 1024 - 160) {
                player.y = 105 - player.height;
                bg2yOff += yDiff;
            } else {
                int netDy = (yDiff + bg2yOff + 160) - 1024;
                bg2yOff += yDiff - netDy;
                player.y += netDy;
            }
        }
    }
}


void drawPlayer() {

    static int frameCounter = 0;
    static int aniFrame = 0;
    if (frameCounter > 10) {
        aniFrame++;
        aniFrame %= 4;
        frameCounter = 0;
    }
    shadowOAM[PLAYER_IDX].attr0 = (player.y & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[PLAYER_IDX].attr1 = (player.x & 0x1FF) | (0 << 14);
    switch (aniFrame)
    {
    case 0:
        shadowOAM[PLAYER_IDX].attr2 = ((28)*32 + ((0)*2)) | ((2) << 10);
        break;
    case 1:
        shadowOAM[PLAYER_IDX].attr2 = ((28)*32 + ((2)*2)) | ((2) << 10);
        break;
    case 2:
        shadowOAM[PLAYER_IDX].attr2 = ((28)*32 + ((4)*2)) | ((2) << 10);
        break;
    case 3:
        shadowOAM[PLAYER_IDX].attr2 = ((28)*32 + ((6)*2)) | ((2) << 10);
        break;
    }
    if (player.facing == LEFT) {
        shadowOAM[PLAYER_IDX].attr1 |= (1 << 12);
    }
    frameCounter++;
}


void firePlayer() {

    fp64 dx, startx, starty;
    if (player.facing == RIGHT) {
        dx = 96;
        startx = player.int_x + ((player.width) << 6);
        starty = player.int_y + ((player.height / 2) << 6);
    } else {
        dx = -96;
        startx = player.int_x - ((bullets[0].width) << 6);
        starty = player.int_y + ((player.height / 2) << 6);
    }
    for (int i = 0; i < 5; i++) {
        if (!bullets[i].active) {
            bullets[i].active = 1;
            bullets[i].dx = dx;
            bullets[i].dy = 0;
            bullets[i].int_x = startx;
            bullets[i].int_y = starty;
            bullets[i].x = ((bullets[i].int_x) >> 6);
            bullets[i].y = ((bullets[i].int_y) >> 6);
            playSoundB(shootsfx_data, shootsfx_length, 0);
            break;
        }
    }
}


void updatePlayer() {

    int slowMode = 0;
    if ((~((*(volatile unsigned short *)0x04000130)) & ((1 << 8)))) {
        slowMode = 1;
    }
    if ((~((*(volatile unsigned short *)0x04000130)) & ((1 << 5)))) {
        player.dx += -(slowMode ? 20 / 2 : 20);
        if (cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9)))) {
            player.dx = -48 * 4;
        }
    } else if ((~((*(volatile unsigned short *)0x04000130)) & ((1 << 4)))) {
        player.dx += (slowMode ? 20 / 2 : 20);
        if (cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9)))) {
            player.dx = 48 * 4;
        }
    } else {
        if (cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9)))) {
            player.dx = 0;
        }
        if (player.dx > 0) {
            player.dx -= 1;
        } else if (player.dx < 0) {
            player.dx += 1;
        }
    }
    if ((~((*(volatile unsigned short *)0x04000130)) & ((1 << 6)))) {
        player.dy += -(slowMode ? 20 / 2 : 20);
        if (cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9)))) {
            player.dy = -48 * 4;
        }
    } else if ((~((*(volatile unsigned short *)0x04000130)) & ((1 << 7)))) {
        player.dy += (slowMode ? 20 / 2 : 20);
        if (cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9)))) {
            player.dy = 48 * 4;
        }
    } else {
        if (cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9)))) {
            player.dy = 0;
        }
        if (player.dy > 0) {
            player.dy -= 1;
        } else if (player.dy < 0) {
            player.dy += 1;
        }
    }
    if (!(cheater && (~((*(volatile unsigned short *)0x04000130)) & ((1 << 9))))) {
        if (player.dx > (slowMode ? 48 / 2 : 48)) player.dx = (slowMode ? 48 / 2 : 48);
        if (player.dx < -(slowMode ? 48 / 2 : 48)) player.dx = -(slowMode ? 48 / 2 : 48);
        if (player.dy > (slowMode ? 48 / 2 : 48)) player.dy = (slowMode ? 48 / 2 : 48);
        if (player.dy < -(slowMode ? 48 / 2 : 48)) player.dy = -(slowMode ? 48 / 2 : 48);
    }


    movePlayer();

    if (player.dx > 0) {
        player.facing = RIGHT;
    } else if (player.dx < 0) {
        player.facing = LEFT;
    }


    if ((!(~(oldButtons) & ((1 << 0))) && (~buttons & ((1 << 0))))) {
        firePlayer();
    }


    drawPlayer();
}


void updateBullet(BULLET* bullet) {
    bullet->int_x += bullet->dx;
    bullet->int_y += bullet->dy;

    if ((bullet->int_x < 0) ||
        (bullet->int_x + ((bullet->width) << 6) > ((1024) << 6)) ||
        (bullet->int_y < 0) ||
        (bullet->int_y + ((bullet->height) << 6) > ((1024) << 6)))
    {
        bullet->active = 0;
    }
    if (collisionCheck(collisionMap, 1024, ((bullet->int_x) >> 6), ((bullet->int_y) >> 6), bullet->width, bullet->height)) {
        bullet->active = 0;
    }

    bullet->x = ((bullet->int_x) >> 6) - bg2xOff;
    bullet->y = ((bullet->int_y) >> 6) - bg2yOff;

    if (bullet->active && !(
        (bullet->x + bullet->width - 1 < 0) ||
        (bullet->x > 240) ||
        (bullet->y + bullet->height - 1 < 0) ||
        (bullet->y > 160)))
    {
        shadowOAM[bullet->spriteIdx].attr0 = (bullet->y & 0xFF) | (0 << 8) | (0 << 14) | (1 << 13);
        shadowOAM[bullet->spriteIdx].attr1 = (bullet->x & 0x1FF) | (0 << 14);

        shadowOAM[bullet->spriteIdx].attr2 = ((31)*32 + ((0)*2)) | ((2) << 10);
    } else {
        shadowOAM[bullet->spriteIdx].attr0 = (2 << 8);
    }
}


void updateEnemy(ENEMY* enemy) {

    enemy->int_x += enemy->dx;
    enemy->int_y += enemy->dy;
    enemy->x = ((enemy->int_x) >> 6) - bg2xOff;
    enemy->y = ((enemy->int_y) >> 6) - bg2yOff;

    if (enemy->active && !(
        (enemy->x + enemy->width - 1 < 0) ||
        (enemy->x > 240) ||
        (enemy->y + enemy->height - 1 < 0) ||
        (enemy->y > 160)))
    {
        drawEnemy(enemy);
    }
}


void updateMine(MINE* mine) {
    mine->int_x += mine->dx;
    mine->int_y += mine->dy;
    mine->x = ((mine->int_x) >> 6) - bg2xOff;
    mine->y = ((mine->int_y) >> 6) - bg2yOff;

    if (mine->active && !(
        (mine->x + mine->width - 1 < 0) ||
        (mine->x > 240) ||
        (mine->y + mine->height - 1 < 0) ||
        (mine->y > 160)))
    {
        drawMine(mine);
    }
}


void updatePickup(PICKUP* pickup) {
    pickup->x = ((pickup->int_x) >> 6) - bg2xOff;
    pickup->y = ((pickup->int_y) >> 6) - bg2yOff;

    if (pickup->active && !(
        (pickup->x + pickup->width - 1 < 0) ||
        (pickup->x > 240) ||
        (pickup->y + pickup->height - 1 < 0) ||
        (pickup->y > 160)))
    {
        drawPickup(pickup);
    }
}


void freeEnemySprites() {
    for (int i = 0; i < 10; i++) {
        shadowOAM[ENEMY1 + i].attr0 = (2 << 8);
    }
    drawnEnemies = 0;
}


void drawEnemy(ENEMY* enemy) {

    if (drawnEnemies < 10) {
        if (enemy->type == BOSS) {
            shadowOAM[ENEMY1 + drawnEnemies].attr0 = (enemy->y & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
            shadowOAM[ENEMY1 + drawnEnemies].attr1 = (enemy->x & 0x1FF) | (2 << 14);
            shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((26)*32 + ((8)*2)) | ((2) << 10);
        } else {
            shadowOAM[ENEMY1 + drawnEnemies].attr0 = (enemy->y & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
            shadowOAM[ENEMY1 + drawnEnemies].attr1 = (enemy->x & 0x1FF) | (0 << 14);
            switch (enemyAniFrame)
            {
            case 0:
                switch (enemy->type)
                {
                case FISH:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((29)*32 + ((0)*2)) | ((2) << 10);
                    break;
                case BARRACUDA:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((28)*32 + ((8)*2)) | ((2) << 10);
                    break;
                case SHARK:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((29)*32 + ((8)*2)) | ((2) << 10);
                    break;
                case ANGLER:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((30)*32 + ((8)*2)) | ((2) << 10);
                    break;
                case PUFFER:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((31)*32 + ((8)*2)) | ((2) << 10);
                    break;
                }
                break;
            case 1:
                switch (enemy->type)
                {
                case FISH:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((29)*32 + ((2)*2)) | ((2) << 10);
                    break;
                case BARRACUDA:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((28)*32 + ((10)*2)) | ((2) << 10);
                    break;
                case SHARK:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((29)*32 + ((10)*2)) | ((2) << 10);
                    break;
                case ANGLER:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((30)*32 + ((10)*2)) | ((2) << 10);
                    break;
                case PUFFER:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((31)*32 + ((10)*2)) | ((2) << 10);
                    break;
                }
                break;
            case 2:
                switch (enemy->type)
                {
                case FISH:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((29)*32 + ((4)*2)) | ((2) << 10);
                    break;
                case BARRACUDA:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((28)*32 + ((12)*2)) | ((2) << 10);
                    break;
                case SHARK:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((29)*32 + ((12)*2)) | ((2) << 10);
                    break;
                case ANGLER:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((30)*32 + ((12)*2)) | ((2) << 10);
                    break;
                case PUFFER:
                    shadowOAM[ENEMY1 + drawnEnemies].attr2 = ((31)*32 + ((12)*2)) | ((2) << 10);
                    break;
                }
                break;
            }
        }
        drawnEnemies++;
    }
}


void freeMineSprites() {
    for (int i = 0; i < 20; i++) {
        shadowOAM[MINE1 + i].attr0 = (2 << 8);
    }
    drawnMines = 0;
}


void drawMine(MINE* mine) {

    if (drawnMines < 20) {
        switch (mineAniFrame)
        {
        case 0:
            shadowOAM[MINE1 + drawnMines].attr2 = ((30)*32 + ((0)*2)) | ((2) << 10);
            break;
        case 1:
            shadowOAM[MINE1 + drawnMines].attr2 = ((30)*32 + ((1)*2)) | ((2) << 10);
            break;
        case 2:
            shadowOAM[MINE1 + drawnMines].attr2 = ((30)*32 + ((2)*2)) | ((2) << 10);
            break;
        }
        shadowOAM[MINE1 + drawnMines].attr0 = (mine->y & 0xFF) | (0 << 8) | (0 << 14) | (1 << 13);
        shadowOAM[MINE1 + drawnMines].attr1 = (mine->x & 0x1FF) | (0 << 14);
        drawnMines++;
    }
}


void freePickupSprites() {
    for (int i = 0; i < 5; i++) {
        shadowOAM[PICKUP1 + i].attr0 = (2 << 8);
    }
    drawnPickups = 0;
}


void drawPickup(PICKUP* pickup) {

    if (drawnPickups < 5) {
        shadowOAM[PICKUP1 + drawnPickups].attr0 = (pickup->y & 0xFF) | (0 << 8) | (0 << 14) | (1 << 13);
        shadowOAM[PICKUP1 + drawnPickups].attr1 = (pickup->x & 0x1FF) | (0 << 14);
        switch (pickup->effect)
        {
        case UPGRADE_TORP:
            shadowOAM[PICKUP1 + drawnPickups].attr2 = ((31)*32 + ((3)*2)) | ((2) << 10);
            break;
        case UPGRADE_BLAST:
            shadowOAM[PICKUP1 + drawnPickups].attr2 = ((31)*32 + ((4)*2)) | ((2) << 10);
            break;
        case UPGRADE_SHIELD:
            shadowOAM[PICKUP1 + drawnPickups].attr2 = ((31)*32 + ((2)*2)) | ((2) << 10);
            break;
        case RESTORE_HP:
            shadowOAM[PICKUP1 + drawnPickups].attr2 = ((31)*32 + ((5)*2)) | ((2) << 10);
            break;
        }
        drawnPickups++;
    }
}


void updateHealthBar() {



    shadowOAM[HEALTHBAR1].attr0 = (2 & 0xFF) | (0 << 8) | (0 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR1].attr1 = (16 & 0x1FF) | (0 << 14);
    if (submarineHp > 0) {
        shadowOAM[HEALTHBAR1].attr2 = ((24)*32 + ((0)*2)) | ((1) << 10);
    } else {
        shadowOAM[HEALTHBAR1].attr2 = ((25)*32 + ((0)*2)) | ((1) << 10);
    }


    shadowOAM[HEALTHBAR2].attr0 = (2 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR2].attr1 = ((24 + 32 * 0) & 0x1FF) | (1 << 14);
    shadowOAM[HEALTHBAR2].attr2 = ((24)*32 + ((5 - tilesRed(1, submarineHp, submarineMaxHp, 26))*2)) | ((1) << 10);

    shadowOAM[HEALTHBAR3].attr0 = (2 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR3].attr1 = ((24 + 32 * 1) & 0x1FF) | (1 << 14);
    shadowOAM[HEALTHBAR3].attr2 = ((24)*32 + ((5 - tilesRed(5, submarineHp, submarineMaxHp, 26))*2)) | ((1) << 10);

    shadowOAM[HEALTHBAR4].attr0 = (2 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR4].attr1 = ((24 + 32 * 2) & 0x1FF) | (1 << 14);
    shadowOAM[HEALTHBAR4].attr2 = ((24)*32 + ((5 - tilesRed(9, submarineHp, submarineMaxHp, 26))*2)) | ((1) << 10);

    shadowOAM[HEALTHBAR5].attr0 = (2 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR5].attr1 = ((24 + 32 * 3) & 0x1FF) | (1 << 14);
    shadowOAM[HEALTHBAR5].attr2 = ((24)*32 + ((5 - tilesRed(13, submarineHp, submarineMaxHp, 26))*2)) | ((1) << 10);

    shadowOAM[HEALTHBAR6].attr0 = (2 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR6].attr1 = ((24 + 32 * 4) & 0x1FF) | (1 << 14);
    shadowOAM[HEALTHBAR6].attr2 = ((24)*32 + ((5 - tilesRed(17, submarineHp, submarineMaxHp, 26))*2)) | ((1) << 10);

    shadowOAM[HEALTHBAR7].attr0 = (2 & 0xFF) | (0 << 8) | (1 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR7].attr1 = ((24 + 32 * 5) & 0x1FF) | (1 << 14);
    shadowOAM[HEALTHBAR7].attr2 = ((24)*32 + ((5 - tilesRed(21, submarineHp, submarineMaxHp, 26))*2)) | ((1) << 10);


    shadowOAM[HEALTHBAR8].attr0 = (2 & 0xFF) | (0 << 8) | (0 << 14) | (1 << 13);
    shadowOAM[HEALTHBAR8].attr1 = ((24 + 32 * 6) & 0x1FF) | (0 << 14) | (1 << 12);
    if (submarineHp > ((25 * submarineMaxHp) / 26)) {
        shadowOAM[HEALTHBAR8].attr2 = ((24)*32 + ((0)*2)) | ((1) << 10);
    } else {
        shadowOAM[HEALTHBAR8].attr2 = ((25)*32 + ((0)*2)) | ((1) << 10);
    }
}
